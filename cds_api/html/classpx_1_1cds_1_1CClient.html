<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>CDS API: px::cds::CClient Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CDS API
   </div>
   <div id="projectbrief">Programmatic interface to the Core Data Store</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classpx_1_1cds_1_1CClient.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classpx_1_1cds_1_1CClient-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">px::cds::CClient Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Singleton class to manage a connection to the CDS, from client side.  
 <a href="classpx_1_1cds_1_1CClient.html#details">More...</a></p>

<p><code>#include &quot;px/cds/client.hpp&quot;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a035c4ea9edea26aa6cfe5be9d55d5699"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpx_1_1cds_1_1CClient.html#a035c4ea9edea26aa6cfe5be9d55d5699">~CClient</a> ()</td></tr>
<tr class="memdesc:a035c4ea9edea26aa6cfe5be9d55d5699"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default Destructor.  <a href="#a035c4ea9edea26aa6cfe5be9d55d5699">More...</a><br/></td></tr>
<tr class="separator:a035c4ea9edea26aa6cfe5be9d55d5699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0afdd28e21cd942f5bd72bb88400df8e"><td class="memItemLeft" align="right" valign="top">PUBLIC bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpx_1_1cds_1_1CClient.html#a0afdd28e21cd942f5bd72bb88400df8e">connect</a> (bool wait=false, <a class="el" href="namespacepx.html#a7acb13796ae56fe8e773fe781eedd790">px::string</a> source_name=<a class="el" href="namespacepx.html#a7acb13796ae56fe8e773fe781eedd790">px::string</a>(&quot;unknown&quot;), uint32_t request_queue_size=4194304, uint32_t <a class="el" href="classpx_1_1cds_1_1CClient.html#a868b03ee1780d9f8475562a47492e5ac">response_queue_size</a>=4194304)</td></tr>
<tr class="memdesc:a0afdd28e21cd942f5bd72bb88400df8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establish a connection to the CDS.  <a href="#a0afdd28e21cd942f5bd72bb88400df8e">More...</a><br/></td></tr>
<tr class="separator:a0afdd28e21cd942f5bd72bb88400df8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad908f7c38d9f004b97bb668182af453"><td class="memItemLeft" align="right" valign="top">PUBLIC void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpx_1_1cds_1_1CClient.html#aad908f7c38d9f004b97bb668182af453">disconnect</a> ()</td></tr>
<tr class="memdesc:aad908f7c38d9f004b97bb668182af453"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnect from the CDS.  <a href="#aad908f7c38d9f004b97bb668182af453">More...</a><br/></td></tr>
<tr class="separator:aad908f7c38d9f004b97bb668182af453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b8862874666e3f1b6e3e6b7ba43d103"><td class="memItemLeft" align="right" valign="top">PUBLIC void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpx_1_1cds_1_1CClient.html#a3b8862874666e3f1b6e3e6b7ba43d103">disconnect_after_callback_fork</a> ()</td></tr>
<tr class="memdesc:a3b8862874666e3f1b6e3e6b7ba43d103"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnect from the CDS after a fork() from background thread.  <a href="#a3b8862874666e3f1b6e3e6b7ba43d103">More...</a><br/></td></tr>
<tr class="separator:a3b8862874666e3f1b6e3e6b7ba43d103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22a72acbc7e6c18244b30e731824a8cb"><td class="memItemLeft" align="right" valign="top">PUBLIC <a class="el" href="namespacepx_1_1cds.html#af5c5d93bab566bfc0b74fbab046f8246">CallbackHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpx_1_1cds_1_1CClient.html#a22a72acbc7e6c18244b30e731824a8cb">register_callback</a> (std::shared_ptr&lt; <a class="el" href="classpx_1_1cds_1_1CCallback.html">CCallback</a> &gt; callback)</td></tr>
<tr class="memdesc:a22a72acbc7e6c18244b30e731824a8cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a callback function to receive (and dequeue) responses.  <a href="#a22a72acbc7e6c18244b30e731824a8cb">More...</a><br/></td></tr>
<tr class="separator:a22a72acbc7e6c18244b30e731824a8cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a721f64149665e1313677905b091a9c70"><td class="memItemLeft" align="right" valign="top">PUBLIC void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpx_1_1cds_1_1CClient.html#a721f64149665e1313677905b091a9c70">unregister_callback</a> (<a class="el" href="namespacepx_1_1cds.html#af5c5d93bab566bfc0b74fbab046f8246">CallbackHandle</a> handle)</td></tr>
<tr class="memdesc:a721f64149665e1313677905b091a9c70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister a previously registered callback structure.  <a href="#a721f64149665e1313677905b091a9c70">More...</a><br/></td></tr>
<tr class="separator:a721f64149665e1313677905b091a9c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a15efa01030aa5cfa0791c071731efa"><td class="memItemLeft" align="right" valign="top">PUBLIC void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpx_1_1cds_1_1CClient.html#a5a15efa01030aa5cfa0791c071731efa">register_unsolicited_callback</a> (std::shared_ptr&lt; <a class="el" href="classpx_1_1cds_1_1CCallback.html">CCallback</a> &gt; callback)</td></tr>
<tr class="memdesc:a5a15efa01030aa5cfa0791c071731efa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the callback function to receive unsolicited messages from the CDS.  <a href="#a5a15efa01030aa5cfa0791c071731efa">More...</a><br/></td></tr>
<tr class="separator:a5a15efa01030aa5cfa0791c071731efa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5757fa58305e1eb9a058667c86239c0"><td class="memItemLeft" align="right" valign="top">PUBLIC bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpx_1_1cds_1_1CClient.html#ad5757fa58305e1eb9a058667c86239c0">have_unsolicited_callback</a> ()</td></tr>
<tr class="memdesc:ad5757fa58305e1eb9a058667c86239c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility to test whether the callback for unsolicited (or subscribed) responses has been set.  <a href="#ad5757fa58305e1eb9a058667c86239c0">More...</a><br/></td></tr>
<tr class="separator:ad5757fa58305e1eb9a058667c86239c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6206eea71f6f9cc5d6aecf8461340dd3"><td class="memItemLeft" align="right" valign="top">PUBLIC void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpx_1_1cds_1_1CClient.html#a6206eea71f6f9cc5d6aecf8461340dd3">unregister_unsolicited_callback</a> ()</td></tr>
<tr class="memdesc:a6206eea71f6f9cc5d6aecf8461340dd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister the previously registered callback function for unsolicited messages from the CDS.  <a href="#a6206eea71f6f9cc5d6aecf8461340dd3">More...</a><br/></td></tr>
<tr class="separator:a6206eea71f6f9cc5d6aecf8461340dd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab991e4c67e1a56d27a883acf0de6d87d"><td class="memItemLeft" align="right" valign="top">PUBLIC uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpx_1_1cds_1_1CClient.html#ab991e4c67e1a56d27a883acf0de6d87d">submit</a> (<a class="el" href="classpx_1_1cds_1_1CRequestResponse.html">CRequestResponse</a> &amp;req, <a class="el" href="namespacepx_1_1cds.html#af5c5d93bab566bfc0b74fbab046f8246">CallbackHandle</a> callback=<a class="el" href="group__special__callback__handles.html#gafe97d8a3313acdb27c9e73c95f42cefa">CALLBACK_NONE</a>, bool sleep_on_full=false)</td></tr>
<tr class="memdesc:ab991e4c67e1a56d27a883acf0de6d87d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a request for CDS processing.  <a href="#ab991e4c67e1a56d27a883acf0de6d87d">More...</a><br/></td></tr>
<tr class="separator:ab991e4c67e1a56d27a883acf0de6d87d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9874266279ebcaaddb29f3681b881d8e"><td class="memItemLeft" align="right" valign="top">PUBLIC std::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classpx_1_1cds_1_1CRequestResponse.html">CRequestResponse</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpx_1_1cds_1_1CClient.html#a9874266279ebcaaddb29f3681b881d8e">submit_wait</a> (<a class="el" href="classpx_1_1cds_1_1CRequestResponse.html">CRequestResponse</a> &amp;req)</td></tr>
<tr class="memdesc:a9874266279ebcaaddb29f3681b881d8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a request for CDS processing, waiting for the response and returning it.  <a href="#a9874266279ebcaaddb29f3681b881d8e">More...</a><br/></td></tr>
<tr class="separator:a9874266279ebcaaddb29f3681b881d8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a868b03ee1780d9f8475562a47492e5ac"><td class="memItemLeft" align="right" valign="top">PUBLIC unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpx_1_1cds_1_1CClient.html#a868b03ee1780d9f8475562a47492e5ac">response_queue_size</a> () const </td></tr>
<tr class="memdesc:a868b03ee1780d9f8475562a47492e5ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current number of enqueued responses.  <a href="#a868b03ee1780d9f8475562a47492e5ac">More...</a><br/></td></tr>
<tr class="separator:a868b03ee1780d9f8475562a47492e5ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40eac56dcc916587b4292b8b1ff210ca"><td class="memItemLeft" align="right" valign="top">PUBLIC std::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classpx_1_1cds_1_1CRequestResponse.html">CRequestResponse</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpx_1_1cds_1_1CClient.html#a40eac56dcc916587b4292b8b1ff210ca">get_queued_response</a> ()</td></tr>
<tr class="memdesc:a40eac56dcc916587b4292b8b1ff210ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the oldest response from the response_queue and return it.  <a href="#a40eac56dcc916587b4292b8b1ff210ca">More...</a><br/></td></tr>
<tr class="separator:a40eac56dcc916587b4292b8b1ff210ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39586f929f5f708fb103f5a00ffec84b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a39586f929f5f708fb103f5a00ffec84b"></a>
PUBLIC bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpx_1_1cds_1_1CClient.html#a39586f929f5f708fb103f5a00ffec84b">update_uid</a> ()</td></tr>
<tr class="memdesc:a39586f929f5f708fb103f5a00ffec84b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the client's UID on the server by reading the process UID, GID, and PID, and sending via SCM_CREDENTIALS. <br/></td></tr>
<tr class="separator:a39586f929f5f708fb103f5a00ffec84b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0582e0c539559b3c2e9e68c51b970fd"><td class="memItemLeft" align="right" valign="top">PUBLIC bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpx_1_1cds_1_1CClient.html#ab0582e0c539559b3c2e9e68c51b970fd">is_connected</a> ()</td></tr>
<tr class="memdesc:ab0582e0c539559b3c2e9e68c51b970fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter which tells if we are still connected to the CDS, or not.  <a href="#ab0582e0c539559b3c2e9e68c51b970fd">More...</a><br/></td></tr>
<tr class="separator:ab0582e0c539559b3c2e9e68c51b970fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1114fc3c57d51f671430b8f9cc1be9b"><td class="memItemLeft" align="right" valign="top">PUBLIC void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpx_1_1cds_1_1CClient.html#ae1114fc3c57d51f671430b8f9cc1be9b">debug_send_raw_to_cds</a> (const void *data, size_t length)</td></tr>
<tr class="memdesc:ae1114fc3c57d51f671430b8f9cc1be9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Debug function for stress testing.  <a href="#ae1114fc3c57d51f671430b8f9cc1be9b">More...</a><br/></td></tr>
<tr class="separator:ae1114fc3c57d51f671430b8f9cc1be9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a43ef2f586d5bf0e6271b6242fd7a4e9b"><td class="memItemLeft" align="right" valign="top">static PUBLIC <a class="el" href="classpx_1_1cds_1_1CClient.html">CClient</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpx_1_1cds_1_1CClient.html#a43ef2f586d5bf0e6271b6242fd7a4e9b">get</a> ()</td></tr>
<tr class="memdesc:a43ef2f586d5bf0e6271b6242fd7a4e9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static Factory function: constructs if necessary, returns existing instance of <a class="el" href="classpx_1_1cds_1_1CClient.html" title="Singleton class to manage a connection to the CDS, from client side. ">CClient</a> otherwise.  <a href="#a43ef2f586d5bf0e6271b6242fd7a4e9b">More...</a><br/></td></tr>
<tr class="separator:a43ef2f586d5bf0e6271b6242fd7a4e9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4a0db52d74fea4645484f9b8c82ffa5"><td class="memItemLeft" align="right" valign="top">static PUBLIC bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpx_1_1cds_1_1CClient.html#aa4a0db52d74fea4645484f9b8c82ffa5">am_i_background_thread</a> ()</td></tr>
<tr class="memdesc:aa4a0db52d74fea4645484f9b8c82ffa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static function that checks whether "this" thread is the CDS Client background thread.  <a href="#aa4a0db52d74fea4645484f9b8c82ffa5">More...</a><br/></td></tr>
<tr class="separator:aa4a0db52d74fea4645484f9b8c82ffa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a641133c5441923381155f221552c56d3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a641133c5441923381155f221552c56d3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpx_1_1cds_1_1CClient.html#a641133c5441923381155f221552c56d3">CClient</a> ()</td></tr>
<tr class="memdesc:a641133c5441923381155f221552c56d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor, private so one must construct using <a class="el" href="classpx_1_1cds_1_1CClient.html#a43ef2f586d5bf0e6271b6242fd7a4e9b" title="Static Factory function: constructs if necessary, returns existing instance of CClient otherwise...">get()</a> <br/></td></tr>
<tr class="separator:a641133c5441923381155f221552c56d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29367f692de9dacb5d367edde2284159"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a29367f692de9dacb5d367edde2284159"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>next_xid</b> (1)</td></tr>
<tr class="separator:a29367f692de9dacb5d367edde2284159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bfb74682042c18a43390f4399fbab1d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4bfb74682042c18a43390f4399fbab1d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>client_socket</b> (-1)</td></tr>
<tr class="separator:a4bfb74682042c18a43390f4399fbab1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5decf7cc1df9d5c132d7186a52fe0b0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab5decf7cc1df9d5c132d7186a52fe0b0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>connected</b> (false)</td></tr>
<tr class="separator:ab5decf7cc1df9d5c132d7186a52fe0b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c0c41e4b6b4fde7c390a733c1dcadb9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7c0c41e4b6b4fde7c390a733c1dcadb9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>bg_thread</b> (nullptr)</td></tr>
<tr class="separator:a7c0c41e4b6b4fde7c390a733c1dcadb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb061650aa981840cbd39c333efe8133"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afb061650aa981840cbd39c333efe8133"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>bg_thread_stop_fd</b> (-1)</td></tr>
<tr class="separator:afb061650aa981840cbd39c333efe8133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba1704be7c6038d84410d4b7744de0f0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aba1704be7c6038d84410d4b7744de0f0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>bg_thread_id</b> (0)</td></tr>
<tr class="separator:aba1704be7c6038d84410d4b7744de0f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e0d6758f507d55d70bc0bf160f93584"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8e0d6758f507d55d70bc0bf160f93584"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>bg_thread_func</b> ()</td></tr>
<tr class="separator:a8e0d6758f507d55d70bc0bf160f93584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab9722874d525e2c0e4d26f0bc5a0fea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aab9722874d525e2c0e4d26f0bc5a0fea"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>get_shm</b> (uint32_t buffer_size)</td></tr>
<tr class="separator:aab9722874d525e2c0e4d26f0bc5a0fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:afb7d695cd27a47ae6e3c4df3abe84fb1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afb7d695cd27a47ae6e3c4df3abe84fb1"></a>
std::map&lt; <a class="el" href="namespacepx_1_1cds.html#af5c5d93bab566bfc0b74fbab046f8246">CallbackHandle</a>, <br class="typebreak"/>
std::shared_ptr&lt; <a class="el" href="classpx_1_1cds_1_1CCallback.html">CCallback</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>callbacks</b></td></tr>
<tr class="separator:afb7d695cd27a47ae6e3c4df3abe84fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa74040c9572480bda0f6b532129ce4ed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa74040c9572480bda0f6b532129ce4ed"></a>
std::shared_ptr&lt; <a class="el" href="classpx_1_1cds_1_1CCallback.html">CCallback</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>unsol_cb</b></td></tr>
<tr class="separator:aa74040c9572480bda0f6b532129ce4ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac564a992e3108426aed8891a4ee555ff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac564a992e3108426aed8891a4ee555ff"></a>
std::mutex&#160;</td><td class="memItemRight" valign="bottom"><b>callbacks_mutex</b></td></tr>
<tr class="separator:ac564a992e3108426aed8891a4ee555ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac706d21bdc5ffc90f384e40a65e9778b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac706d21bdc5ffc90f384e40a65e9778b"></a>
<a class="el" href="namespacepx_1_1cds.html#af5c5d93bab566bfc0b74fbab046f8246">CallbackHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><b>next_handle</b></td></tr>
<tr class="separator:ac706d21bdc5ffc90f384e40a65e9778b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50e4017352f21228f496ae65545c2712"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50e4017352f21228f496ae65545c2712"></a>
std::deque&lt; std::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classpx_1_1cds_1_1CRequestResponse.html">CRequestResponse</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>response_queue</b></td></tr>
<tr class="separator:a50e4017352f21228f496ae65545c2712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c614390987fee644b36a42b262bc1a6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9c614390987fee644b36a42b262bc1a6"></a>
std::mutex&#160;</td><td class="memItemRight" valign="bottom"><b>response_queue_mutex</b></td></tr>
<tr class="separator:a9c614390987fee644b36a42b262bc1a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0341f95e93d2e52682b995f151c1a544"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0341f95e93d2e52682b995f151c1a544"></a>
toolkit::ipc::CIPCEventQueue *&#160;</td><td class="memItemRight" valign="bottom"><b>request_queue</b></td></tr>
<tr class="separator:a0341f95e93d2e52682b995f151c1a544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe0ff6a545e20ad258bf51933aabf7a2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abe0ff6a545e20ad258bf51933aabf7a2"></a>
std::mutex&#160;</td><td class="memItemRight" valign="bottom"><b>request_queue_mutex</b></td></tr>
<tr class="separator:abe0ff6a545e20ad258bf51933aabf7a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac94ea1afa1692ef44ddb1755fd8f9c9a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac94ea1afa1692ef44ddb1755fd8f9c9a"></a>
toolkit::ipc::CIPCEventQueue *&#160;</td><td class="memItemRight" valign="bottom"><b>cds_response_queue</b></td></tr>
<tr class="separator:ac94ea1afa1692ef44ddb1755fd8f9c9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad992ee42c59f02d6f5b254bdedaf22c2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad992ee42c59f02d6f5b254bdedaf22c2"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>request_queue_size</b></td></tr>
<tr class="separator:ad992ee42c59f02d6f5b254bdedaf22c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a010f5ca2e3bb38290b8d713c39f20db1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a010f5ca2e3bb38290b8d713c39f20db1"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>cds_response_queue_size</b></td></tr>
<tr class="separator:a010f5ca2e3bb38290b8d713c39f20db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2624b2ceabc795c7129eb4f72326f6ef"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2624b2ceabc795c7129eb4f72326f6ef"></a>
struct pollfd&#160;</td><td class="memItemRight" valign="bottom"><b>request_pollfd</b> [2]</td></tr>
<tr class="separator:a2624b2ceabc795c7129eb4f72326f6ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae73e69ff2811df7d7d9525836c9307a2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae73e69ff2811df7d7d9525836c9307a2"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>next_xid</b></td></tr>
<tr class="separator:ae73e69ff2811df7d7d9525836c9307a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a170284bede0818fecbc08b2e7a51efc8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a170284bede0818fecbc08b2e7a51efc8"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>client_socket</b></td></tr>
<tr class="separator:a170284bede0818fecbc08b2e7a51efc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7ab7f8c9c50f0189fc874fba5d5a6e0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad7ab7f8c9c50f0189fc874fba5d5a6e0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>connected</b></td></tr>
<tr class="separator:ad7ab7f8c9c50f0189fc874fba5d5a6e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d8a904793413362920369f3dfc2fdc8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2d8a904793413362920369f3dfc2fdc8"></a>
std::thread *&#160;</td><td class="memItemRight" valign="bottom"><b>bg_thread</b></td></tr>
<tr class="separator:a2d8a904793413362920369f3dfc2fdc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaecb876f1ad51b349d112b2996e4eef"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adaecb876f1ad51b349d112b2996e4eef"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>bg_thread_stop_fd</b></td></tr>
<tr class="separator:adaecb876f1ad51b349d112b2996e4eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9f019256301309a57638719bf5f8086"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad9f019256301309a57638719bf5f8086"></a>
std::thread::id&#160;</td><td class="memItemRight" valign="bottom"><b>bg_thread_id</b></td></tr>
<tr class="separator:ad9f019256301309a57638719bf5f8086"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Singleton class to manage a connection to the CDS, from client side. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a035c4ea9edea26aa6cfe5be9d55d5699"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">px::cds::CClient::~CClient </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default Destructor. </p>
<p>Performs a <a class="el" href="classpx_1_1cds_1_1CClient.html#aad908f7c38d9f004b97bb668182af453" title="Disconnect from the CDS. ">disconnect()</a>, if connected to the CDS, and removes this global, per-application instance of the CDS Client. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a43ef2f586d5bf0e6271b6242fd7a4e9b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static PUBLIC <a class="el" href="classpx_1_1cds_1_1CClient.html">CClient</a>* px::cds::CClient::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static Factory function: constructs if necessary, returns existing instance of <a class="el" href="classpx_1_1cds_1_1CClient.html" title="Singleton class to manage a connection to the CDS, from client side. ">CClient</a> otherwise. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the CDS Client instance for this application. This is a pointer to the global, per-application instance of the CDS Client. Don't delete this pointer unless the program is exiting or for some reason will not use the CDS again.</dd></dl>
<p>Fast enough that you can use <a class="el" href="classpx_1_1cds_1_1CClient.html#a43ef2f586d5bf0e6271b6242fd7a4e9b" title="Static Factory function: constructs if necessary, returns existing instance of CClient otherwise...">px::cds::CClient::get()</a>-&gt;whatever() for all your calls instead of caching the value. </p>

</div>
</div>
<a class="anchor" id="a0afdd28e21cd942f5bd72bb88400df8e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PUBLIC bool px::cds::CClient::connect </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>wait</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepx.html#a7acb13796ae56fe8e773fe781eedd790">px::string</a>&#160;</td>
          <td class="paramname"><em>source_name</em> = <code><a class="el" href="namespacepx.html#a7acb13796ae56fe8e773fe781eedd790">px::string</a>(&quot;unknown&quot;)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>request_queue_size</em> = <code>4194304</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>response_queue_size</em> = <code>4194304</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Establish a connection to the CDS. </p>
<p>A successful connection will create a background thread for calling callbacks. If this process is already connected, does nothing and returns true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wait</td><td>If true, then do not return until CDS is available (the connection attempt may still return false, though). If false, short waits may still occur if the CDS is available. </td></tr>
    <tr><td class="paramname">source_name</td><td>Name associated with this connection, for logging purposes. </td></tr>
    <tr><td class="paramname">request_queue_size</td><td>Memory allocation for buffer pending requests, in bytes. Must be at least 4096. </td></tr>
    <tr><td class="paramname">response_queue_size</td><td>Memory allocation for queued responses, in bytes. Must be at least 4096.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">May</td><td>throw generic_err.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the connection is successful, false otherwise (eg, if the CDS is not running). If false, no further efforts to use this Client should occur until the connection can be established. </dd></dl>

</div>
</div>
<a class="anchor" id="aad908f7c38d9f004b97bb668182af453"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PUBLIC void px::cds::CClient::disconnect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disconnect from the CDS. </p>
<p>Unprocessed requests and responses are lost - use <a class="el" href="classpx_1_1cds_1_1CNotifyCompletion.html" title="Return when previously-queued messages have been processed. ">px::cds::CNotifyCompletion</a> if you need to see if any requests are still unprocessed. Background thread is terminated (this may involve some waiting). All callbacks are unregistered. </p>

</div>
</div>
<a class="anchor" id="a3b8862874666e3f1b6e3e6b7ba43d103"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PUBLIC void px::cds::CClient::disconnect_after_callback_fork </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disconnect from the CDS after a fork() from background thread. </p>
<p>The background thread is the only one that will exist in the child. Call this and then call <a class="el" href="classpx_1_1cds_1_1CClient.html#a0afdd28e21cd942f5bd72bb88400df8e" title="Establish a connection to the CDS. ">connect()</a> to do further CDS operations after a fork() from a callback function. </p>

</div>
</div>
<a class="anchor" id="a22a72acbc7e6c18244b30e731824a8cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PUBLIC <a class="el" href="namespacepx_1_1cds.html#af5c5d93bab566bfc0b74fbab046f8246">CallbackHandle</a> px::cds::CClient::register_callback </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classpx_1_1cds_1_1CCallback.html">CCallback</a> &gt;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a callback function to receive (and dequeue) responses. </p>
<p>These will be responses to <a class="el" href="classpx_1_1cds_1_1CClient.html#ab991e4c67e1a56d27a883acf0de6d87d" title="Submit a request for CDS processing. ">submit()</a> requests. This function may be called more than once; this client class keeps a map of the registered callback(s) keyed by their callback handles.</p>
<p>If a callback is running, this will wait until it finishes.</p>
<p>If the callback structure already contains a handle (because this callback has been previously registered), that handle will be returned and no attempt will be made to re-register the callback. (So don't set the handle yourself.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>The callback structure (derived from <a class="el" href="classpx_1_1cds_1_1CCallback.html" title="The abstract Callback prototype for CDS responses. ">CCallback</a>) containing the function to be invoked. Must not be null.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the handle that identifies this callback instance. Returns CALLBACK_NONE if can't register the callback (eg, null pointer). </dd></dl>

</div>
</div>
<a class="anchor" id="a721f64149665e1313677905b091a9c70"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PUBLIC void px::cds::CClient::unregister_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepx_1_1cds.html#af5c5d93bab566bfc0b74fbab046f8246">CallbackHandle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregister a previously registered callback structure. </p>
<p>If a callback is running, this will wait until it finishes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle that identifies this callback instance, which was returned by <a class="el" href="classpx_1_1cds_1_1CClient.html#a22a72acbc7e6c18244b30e731824a8cb" title="Register a callback function to receive (and dequeue) responses. ">register_callback()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5a15efa01030aa5cfa0791c071731efa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PUBLIC void px::cds::CClient::register_unsolicited_callback </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classpx_1_1cds_1_1CCallback.html">CCallback</a> &gt;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the callback function to receive unsolicited messages from the CDS. </p>
<p>These will be subscription events or the unusual unexpected message from the CDS. There is only this one instance of the unsolicited callback handler per client connection, so this function should only be called once.</p>
<p>If a callback is running, this will wait until it finishes.</p>
<dl class="section note"><dt>Note</dt><dd>If no callback has been registered, unsolicited responses will go onto the response_queue member of this Client. </dd>
<dd>
There can only be one unsolicited callback per client; if you use the px::asio::CCdsConnection, it will register its handle_response() as its unsolicited callback function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>The callback structure (derived from <a class="el" href="classpx_1_1cds_1_1CCallback.html" title="The abstract Callback prototype for CDS responses. ">CCallback</a>) containing the function to be invoked. Must not be null. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad5757fa58305e1eb9a058667c86239c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PUBLIC bool px::cds::CClient::have_unsolicited_callback </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility to test whether the callback for unsolicited (or subscribed) responses has been set. </p>
<dl class="section return"><dt>Returns</dt><dd>True if unsol_cb has been set, else False. </dd></dl>

</div>
</div>
<a class="anchor" id="a6206eea71f6f9cc5d6aecf8461340dd3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PUBLIC void px::cds::CClient::unregister_unsolicited_callback </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregister the previously registered callback function for unsolicited messages from the CDS. </p>
<p>If a callback is running, this will wait until it finishes. </p>

</div>
</div>
<a class="anchor" id="ab991e4c67e1a56d27a883acf0de6d87d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PUBLIC uint32_t px::cds::CClient::submit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpx_1_1cds_1_1CRequestResponse.html">CRequestResponse</a> &amp;&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepx_1_1cds.html#af5c5d93bab566bfc0b74fbab046f8246">CallbackHandle</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code><a class="el" href="group__special__callback__handles.html#gafe97d8a3313acdb27c9e73c95f42cefa">CALLBACK_NONE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sleep_on_full</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a request for CDS processing. </p>
<p>Sets the transaction_id and callback_handle members. Safe to call from multiple threads.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>The request structure, derived from <a class="el" href="classpx_1_1cds_1_1CRequestResponse.html" title="All CDS interprocess messages are subclasses of this. ">CRequestResponse</a>. </td></tr>
    <tr><td class="paramname">callback</td><td>The handle of the callback structure to be invoked when done, derived from <a class="el" href="classpx_1_1cds_1_1CCallback.html" title="The abstract Callback prototype for CDS responses. ">CCallback</a>. If set to CALLBACK_NONE, the CDS will not send any response (and the returned transaction ID will always be 0). If set to CALLBACK_ENQUEUE, no callback will be made, and the response will be left on the response queue. </td></tr>
    <tr><td class="paramname">sleep_on_full</td><td>If true and the request queue is full, will sleep until there is space. If false and the request queue is full, will discard the request.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">px::no_connection</td><td>if the connection has not been established or if it drops for some reason </td></tr>
    <tr><td class="paramname">px::too_much_data</td><td>if the request is too large to ever be able to fit in the buffer </td></tr>
    <tr><td class="paramname">px::generic_err</td><td>other causes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transaction_id the CDS provides to identify the response to this request, or 0 if the request was discarded (could not be queued) or 0 if there is no callback provided. </dd></dl>

</div>
</div>
<a class="anchor" id="a9874266279ebcaaddb29f3681b881d8e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PUBLIC std::shared_ptr&lt;<a class="el" href="classpx_1_1cds_1_1CRequestResponse.html">CRequestResponse</a>&gt; px::cds::CClient::submit_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpx_1_1cds_1_1CRequestResponse.html">CRequestResponse</a> &amp;&#160;</td>
          <td class="paramname"><em>req</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a request for CDS processing, waiting for the response and returning it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>The request structure, derived from <a class="el" href="classpx_1_1cds_1_1CRequestResponse.html" title="All CDS interprocess messages are subclasses of this. ">CRequestResponse</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">no_connection</td><td>if the connection has not been established or if it drops for some reason </td></tr>
    <tr><td class="paramname">too_much_data</td><td>if the request is too large to ever be able to fit in the buffer </td></tr>
    <tr><td class="paramname">generic_err</td><td>other causes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The results of the CDS command, in a structure derived from <a class="el" href="classpx_1_1cds_1_1CRequestResponse.html" title="All CDS interprocess messages are subclasses of this. ">CRequestResponse</a>. Will return an empty shared_ptr if there is some error (that doesn't throw). </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Uses a wait on the callback background thread. If this is called from that background thread (e.g. from a <a class="el" href="classpx_1_1cds_1_1CCallback.html" title="The abstract Callback prototype for CDS responses. ">CCallback</a>) it will deadlock. </dd></dl>

</div>
</div>
<a class="anchor" id="a868b03ee1780d9f8475562a47492e5ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PUBLIC unsigned int px::cds::CClient::response_queue_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current number of enqueued responses. </p>
<p>There are two ways that responses are enqueued on the response_queue: 1) They are responses to requests submitted with callback handle CALLBACK_ENQUEUE 2) They are unsolicited responses (messages) when no unsolicited callback has been registered.</p>
<p>May be used to poll the queue (though it never sleeps) as the number of items in the queue never decreases unless you call <a class="el" href="classpx_1_1cds_1_1CClient.html#a40eac56dcc916587b4292b8b1ff210ca" title="Remove the oldest response from the response_queue and return it. ">get_queued_response()</a>.</p>
<p>Safe to call from multiple threads.</p>
<dl class="section return"><dt>Returns</dt><dd>The current number of enqueued responses. </dd></dl>

</div>
</div>
<a class="anchor" id="a40eac56dcc916587b4292b8b1ff210ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PUBLIC std::shared_ptr&lt;<a class="el" href="classpx_1_1cds_1_1CRequestResponse.html">CRequestResponse</a>&gt; px::cds::CClient::get_queued_response </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the oldest response from the response_queue and return it. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to a CDS response structure derived from <a class="el" href="classpx_1_1cds_1_1CRequestResponse.html" title="All CDS interprocess messages are subclasses of this. ">CRequestResponse</a>. If the queue is empty an empty shared_ptr is returned.</dd></dl>
<p>Safe to call from multiple threads. </p>

</div>
</div>
<a class="anchor" id="aa4a0db52d74fea4645484f9b8c82ffa5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static PUBLIC bool px::cds::CClient::am_i_background_thread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static function that checks whether "this" thread is the CDS Client background thread. </p>
<p>May seem like a silly question to ask, but it is actually hard to tell when inside a CdsHandler function that can be called by either the callbacks owned by the background thread or the application code.</p>
<dl class="section return"><dt>Returns</dt><dd>True if "this" thread is the Client's background thread. </dd></dl>

</div>
</div>
<a class="anchor" id="ab0582e0c539559b3c2e9e68c51b970fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool px::cds::CClient::is_connected </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter which tells if we are still connected to the CDS, or not. </p>
<dl class="section return"><dt>Returns</dt><dd>True if connected to the CDS. </dd></dl>

</div>
</div>
<a class="anchor" id="ae1114fc3c57d51f671430b8f9cc1be9b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PUBLIC void px::cds::CClient::debug_send_raw_to_cds </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Debug function for stress testing. </p>
<p>Sends the included string of bytes to the CDS, unfiltered. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>client.hpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacepx.html">px</a></li><li class="navelem"><a class="el" href="namespacepx_1_1cds.html">cds</a></li><li class="navelem"><a class="el" href="classpx_1_1cds_1_1CClient.html">CClient</a></li>
    <li class="footer">Generated on Fri May 7 2021 20:24:15 for CDS API by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.5 </li>
  </ul>
</div>
</body>
</html>
