<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>libipc: toolkit::ipc::CIPCEventQueue Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libipc
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="../../annotated.html"><span>Classes</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="../../annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="../../classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="../../inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="../../functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('d3/dcf/classtoolkit_1_1ipc_1_1CIPCEventQueue.html','../../');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="../../d2/d59/classtoolkit_1_1ipc_1_1CIPCEventQueue-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">toolkit::ipc::CIPCEventQueue Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Asynchronous event queue.  
 <a href="../../d3/dcf/classtoolkit_1_1ipc_1_1CIPCEventQueue.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../d5/d07/ipc__event__queue_8hpp_source.html">ipc_event_queue.hpp</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for toolkit::ipc::CIPCEventQueue:</div>
<div class="dyncontent">
<div class="center"><img src="../../d6/d9a/classtoolkit_1_1ipc_1_1CIPCEventQueue__coll__graph.png" border="0" usemap="#toolkit_1_1ipc_1_1CIPCEventQueue_coll__map" alt="Collaboration graph"/></div>
<map name="toolkit_1_1ipc_1_1CIPCEventQueue_coll__map" id="toolkit_1_1ipc_1_1CIPCEventQueue_coll__map">
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:adcccc57058d40ded06214e69336ff8d9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dcf/classtoolkit_1_1ipc_1_1CIPCEventQueue.html#adcccc57058d40ded06214e69336ff8d9">CIPCEventQueue</a> (int shm_fd, size_t capacity, int eventfd, bool writer)</td></tr>
<tr class="memdesc:adcccc57058d40ded06214e69336ff8d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#adcccc57058d40ded06214e69336ff8d9">More...</a><br/></td></tr>
<tr class="separator:adcccc57058d40ded06214e69336ff8d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af441e383e0b5bc926cf6db4d6ca7fb62"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dcf/classtoolkit_1_1ipc_1_1CIPCEventQueue.html#af441e383e0b5bc926cf6db4d6ca7fb62">~CIPCEventQueue</a> ()</td></tr>
<tr class="memdesc:af441e383e0b5bc926cf6db4d6ca7fb62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#af441e383e0b5bc926cf6db4d6ca7fb62">More...</a><br/></td></tr>
<tr class="separator:af441e383e0b5bc926cf6db4d6ca7fb62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7c4323062f6246fbf55cde17fa5f6b3"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dcf/classtoolkit_1_1ipc_1_1CIPCEventQueue.html#ac7c4323062f6246fbf55cde17fa5f6b3">get</a> () const </td></tr>
<tr class="memdesc:ac7c4323062f6246fbf55cde17fa5f6b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current position of the shared memory buffer.  <a href="#ac7c4323062f6246fbf55cde17fa5f6b3">More...</a><br/></td></tr>
<tr class="separator:ac7c4323062f6246fbf55cde17fa5f6b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5726289ba1ba6b35d8ef5d51ae9dae15"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dcf/classtoolkit_1_1ipc_1_1CIPCEventQueue.html#a5726289ba1ba6b35d8ef5d51ae9dae15">chunk_size</a> () const </td></tr>
<tr class="memdesc:a5726289ba1ba6b35d8ef5d51ae9dae15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum data size that can be written to the queue in a single message.  <a href="#a5726289ba1ba6b35d8ef5d51ae9dae15">More...</a><br/></td></tr>
<tr class="separator:a5726289ba1ba6b35d8ef5d51ae9dae15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9732c7e6ea891726bef6d3ce1b85fcd8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dcf/classtoolkit_1_1ipc_1_1CIPCEventQueue.html#a9732c7e6ea891726bef6d3ce1b85fcd8">write</a> (size_t msglen)</td></tr>
<tr class="memdesc:a9732c7e6ea891726bef6d3ce1b85fcd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a new message to the buffer.  <a href="#a9732c7e6ea891726bef6d3ce1b85fcd8">More...</a><br/></td></tr>
<tr class="separator:a9732c7e6ea891726bef6d3ce1b85fcd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb23d3eff81a84372fbdd3eae8869a49"><td class="memItemLeft" align="right" valign="top">std::pair&lt; size_t, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dcf/classtoolkit_1_1ipc_1_1CIPCEventQueue.html#adb23d3eff81a84372fbdd3eae8869a49">read</a> ()</td></tr>
<tr class="memdesc:adb23d3eff81a84372fbdd3eae8869a49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a new message from the buffer.  <a href="#adb23d3eff81a84372fbdd3eae8869a49">More...</a><br/></td></tr>
<tr class="separator:adb23d3eff81a84372fbdd3eae8869a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbaa4566c94804ff237cd5c23cfcd9c4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dcf/classtoolkit_1_1ipc_1_1CIPCEventQueue.html#acbaa4566c94804ff237cd5c23cfcd9c4">fd</a> () const </td></tr>
<tr class="memdesc:acbaa4566c94804ff237cd5c23cfcd9c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for the underlying send/receive FD.  <a href="#acbaa4566c94804ff237cd5c23cfcd9c4">More...</a><br/></td></tr>
<tr class="separator:acbaa4566c94804ff237cd5c23cfcd9c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c207fdc4715f3554cdbc62f5990578f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dcf/classtoolkit_1_1ipc_1_1CIPCEventQueue.html#a6c207fdc4715f3554cdbc62f5990578f">is_writer</a> () const </td></tr>
<tr class="memdesc:a6c207fdc4715f3554cdbc62f5990578f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this object on the writing / input end of the event queue?  <a href="#a6c207fdc4715f3554cdbc62f5990578f">More...</a><br/></td></tr>
<tr class="separator:a6c207fdc4715f3554cdbc62f5990578f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ab1ff3c74141d23bde9986d7db18a4123"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dcf/classtoolkit_1_1ipc_1_1CIPCEventQueue.html#ab1ff3c74141d23bde9986d7db18a4123">_memory</a></td></tr>
<tr class="memdesc:ab1ff3c74141d23bde9986d7db18a4123"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared memory segment used for this queue's communication.  <a href="#ab1ff3c74141d23bde9986d7db18a4123">More...</a><br/></td></tr>
<tr class="separator:ab1ff3c74141d23bde9986d7db18a4123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa00761d797965664eaaf85d2f27d59b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dcf/classtoolkit_1_1ipc_1_1CIPCEventQueue.html#afa00761d797965664eaaf85d2f27d59b">_capacity</a></td></tr>
<tr class="memdesc:afa00761d797965664eaaf85d2f27d59b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum length of this queue, i.e.  <a href="#afa00761d797965664eaaf85d2f27d59b">More...</a><br/></td></tr>
<tr class="separator:afa00761d797965664eaaf85d2f27d59b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a565ee1b36705c2c9d6fceeb22eb0610a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dcf/classtoolkit_1_1ipc_1_1CIPCEventQueue.html#a565ee1b36705c2c9d6fceeb22eb0610a">_max_chunk</a></td></tr>
<tr class="memdesc:a565ee1b36705c2c9d6fceeb22eb0610a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum size of a single written chunk, i.e.  <a href="#a565ee1b36705c2c9d6fceeb22eb0610a">More...</a><br/></td></tr>
<tr class="separator:a565ee1b36705c2c9d6fceeb22eb0610a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add5a6d267b009340685f08b6393038da"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dcf/classtoolkit_1_1ipc_1_1CIPCEventQueue.html#add5a6d267b009340685f08b6393038da">_write_boundary</a></td></tr>
<tr class="memdesc:add5a6d267b009340685f08b6393038da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queue boundary beyond which we force any new messages to wrap-around to the beginning; this is _capacity minus the maximum message size (since we must allow for the last message starting just before this boundary).  <a href="#add5a6d267b009340685f08b6393038da">More...</a><br/></td></tr>
<tr class="separator:add5a6d267b009340685f08b6393038da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49e9a9ab51a285b3f994bb62cf6a54c2"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dcf/classtoolkit_1_1ipc_1_1CIPCEventQueue.html#a49e9a9ab51a285b3f994bb62cf6a54c2">_multiplier</a></td></tr>
<tr class="memdesc:a49e9a9ab51a285b3f994bb62cf6a54c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplier used to align _capacity with the maximum value held in an eventfd() before it blocks; doing this allows us to ensure that upon a queue-full condition, we block until the receiver reads some more data.  <a href="#a49e9a9ab51a285b3f994bb62cf6a54c2">More...</a><br/></td></tr>
<tr class="separator:a49e9a9ab51a285b3f994bb62cf6a54c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf7cad896fac6d7f1ccb9defa8482ce7"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dcf/classtoolkit_1_1ipc_1_1CIPCEventQueue.html#abf7cad896fac6d7f1ccb9defa8482ce7">_offset</a></td></tr>
<tr class="memdesc:abf7cad896fac6d7f1ccb9defa8482ce7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current position/offset in the queue (in bytes)  <a href="#abf7cad896fac6d7f1ccb9defa8482ce7">More...</a><br/></td></tr>
<tr class="separator:abf7cad896fac6d7f1ccb9defa8482ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a263fcda6ffabfbab61cb52aafbc1e373"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dcf/classtoolkit_1_1ipc_1_1CIPCEventQueue.html#a263fcda6ffabfbab61cb52aafbc1e373">_old_offset</a></td></tr>
<tr class="memdesc:a263fcda6ffabfbab61cb52aafbc1e373"><td class="mdescLeft">&#160;</td><td class="mdescRight">The oldest in-memory position/offset in the queue (in bytes)  <a href="#a263fcda6ffabfbab61cb52aafbc1e373">More...</a><br/></td></tr>
<tr class="separator:a263fcda6ffabfbab61cb52aafbc1e373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfd845cdf2ad35b0605412f04eadd6ee"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dcf/classtoolkit_1_1ipc_1_1CIPCEventQueue.html#abfd845cdf2ad35b0605412f04eadd6ee">_stashed_bytes</a></td></tr>
<tr class="memdesc:abfd845cdf2ad35b0605412f04eadd6ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of bytes still remaining to be read when an incoming series of messages has been split across the end of the buffer.  <a href="#abfd845cdf2ad35b0605412f04eadd6ee">More...</a><br/></td></tr>
<tr class="separator:abfd845cdf2ad35b0605412f04eadd6ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89f12be6eb37f4a733c995c03ad36e54"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dcf/classtoolkit_1_1ipc_1_1CIPCEventQueue.html#a89f12be6eb37f4a733c995c03ad36e54">_eventfd</a></td></tr>
<tr class="memdesc:a89f12be6eb37f4a733c995c03ad36e54"><td class="mdescLeft">&#160;</td><td class="mdescRight">The eventfd() descriptor used to signal the presence of data to the consumer process.  <a href="#a89f12be6eb37f4a733c995c03ad36e54">More...</a><br/></td></tr>
<tr class="separator:a89f12be6eb37f4a733c995c03ad36e54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a596e516f4a0b76aa04cc79bfa718c5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dcf/classtoolkit_1_1ipc_1_1CIPCEventQueue.html#a1a596e516f4a0b76aa04cc79bfa718c5">_writer</a></td></tr>
<tr class="memdesc:a1a596e516f4a0b76aa04cc79bfa718c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this object on the write-side of the event queue?  <a href="#a1a596e516f4a0b76aa04cc79bfa718c5">More...</a><br/></td></tr>
<tr class="separator:a1a596e516f4a0b76aa04cc79bfa718c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Asynchronous event queue. </p>
<p>This class implements a shared-memory queue structure for asynchronous event delivery. Usage and implementation of this queue are slightly more complex than the command/response queue, due to these differences:</p>
<ol type="1">
<li>Communication is one-way, i.e. one process holds a handle to the "writing end" of the queue, while another holds a handle to the "reading end".</li>
<li>Events occur asynchronously, and must be buffered/preserved up to some maximum size if the reader is not yet ready to receive them.</li>
</ol>
<p>In order to handle #2 efficiently, this queue utilizes a shared memory segment as a sort of ring buffer for event messages. The writer appends new messages to the tail end of the queue, while the reader reads messages from the head of the queue. Most of the complex corner-cases occur when we hit the end of the queue, and need to wrap-around to the beginning of the shared memory segment again. Although it's a bit complicated, this is an extremely efficient way to handle buffered asynchronous messages.</p>
<p>This results in a couple of key structural differences from the relatively simple command queue:</p>
<ul>
<li>The buffer pointer (returned by <a class="el" href="../../d3/dcf/classtoolkit_1_1ipc_1_1CIPCEventQueue.html#ac7c4323062f6246fbf55cde17fa5f6b3" title="Get the current position of the shared memory buffer. ">get()</a>) is not constant, but must be re-calculated before each read/write operation.</li>
<li>The eventfd descriptor used for signaling doesn't contain the number of outstanding bytes in the queue, but rather the number of bytes multiplied by a constant which is designed to "overflow" the counter (make it the maximum 64-bit value) when the queue is at a point where it should be considered full. That lets us <a class="el" href="../../d3/dcf/classtoolkit_1_1ipc_1_1CIPCEventQueue.html#adb23d3eff81a84372fbdd3eae8869a49" title="Read a new message from the buffer. ">read()</a>, <a class="el" href="../../d3/dcf/classtoolkit_1_1ipc_1_1CIPCEventQueue.html#a9732c7e6ea891726bef6d3ce1b85fcd8" title="Write a new message to the buffer. ">write()</a>, and poll() the eventfd and get semantics that make sense. E.g. <a class="el" href="../../d3/dcf/classtoolkit_1_1ipc_1_1CIPCEventQueue.html#a9732c7e6ea891726bef6d3ce1b85fcd8" title="Write a new message to the buffer. ">write()</a> will fail once the queue is "full", because our eventfd value will have been incremented close to 0xffffffffffffffff. This lets the sender know that the queue is full, so it can either block or drop the new messages.</li>
<li>Sizing of the queue is a bit more complicated, in order to support the worst-case scenarios we might encounter. The overall queue capacity is used to map the shared memory segment, but then that gets broken into separate "regions":<ul>
<li>The last size_t is reserved for handling the funky case in which multiple pending messages are split across the buffer boundary (i.e. when we loop back around to the beginning).</li>
<li>An extra chunk at the end (just before that size_t) is reserved for overflow when a single write starts near the end of the buffer. We don't know how much the user wants to write until they've already copied their data over, and even if we did know ahead of time, we'd have to reserve a chunk to separate the tail of the queue from the head of the section that the reader may still be processing to avoid stomping on him.</li>
</ul>
</li>
</ul>
<p>Here's an example memory map: </p>
<pre class="fragment">A      F               B                       A               O      S
</pre><p> |=======|=====|=========================|====================|===========|=| | Main buffer | |</p>
<p>A = memory region written by the writer, which has definitely not been read by the reader yet B = memory region that may possibly still be unread by the reader (if he's lagging way behind), but is probably mostly read at this point U = free memory at the tail of A; this is where the next message will be written to (until A's size reaches 1/2 of "main buffer", at which point the queue is considered full and no more writes can happen until the reader moves the B/A boundary forward) O = overflow space that's usually not used (much), but is required just in case there's a large message written at the tail end of "main buffer". S = location of a special size value, used when the writer wraps around the end of the main buffer.</p>
<p>Note that this is a VIRTUAL memory mapping. The size of the mapped shared memory region can be very large, but only the memory actually in current use will remain resident. For the map above, if the reader makes another call to <a class="el" href="../../d3/dcf/classtoolkit_1_1ipc_1_1CIPCEventQueue.html#adb23d3eff81a84372fbdd3eae8869a49" title="Read a new message from the buffer. ">read()</a>, all of the pages shown in the "B" region will be unmapped before we attempt to read from the eventfd, as they're no longer necessary now that the reader has moved on to the next set of messages. </p>

<p>Definition at line <a class="el" href="../../d5/d07/ipc__event__queue_8hpp_source.html#l00088">88</a> of file <a class="el" href="../../d5/d07/ipc__event__queue_8hpp_source.html">ipc_event_queue.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="adcccc57058d40ded06214e69336ff8d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CIPCEventQueue::CIPCEventQueue </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>shm_fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>eventfd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>writer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shm_fd</td><td>Shared memory file descriptor, which will be mapped internally with mmap() and then closed</td></tr>
    <tr><td class="paramname">capacity</td><td>Maximum length of this queue</td></tr>
    <tr><td class="paramname">eventfd</td><td>The eventfd() descriptor used to signal the presence of data to the consumer process; ownership of this FD is taken over by the object. This should be a non-blocking FD, otherwise the server may block when trying to add events to a full queue.</td></tr>
    <tr><td class="paramname">writer</td><td>True if this object is on the writing end of the message queue (in which case the peer process has a corresponding object with writer==false)</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../dc/d6d/structtoolkit_1_1ipc_1_1generic__err.html" title="Base exception class. ">generic_err</a></td><td>Thrown if there is an error initializing the shared memory queue </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d4/d28/ipc__event__queue_8cpp_source.html#l00019">19</a> of file <a class="el" href="../../d4/d28/ipc__event__queue_8cpp_source.html">ipc_event_queue.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="af441e383e0b5bc926cf6db4d6ca7fb62"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CIPCEventQueue::~CIPCEventQueue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor. </p>

<p>Definition at line <a class="el" href="../../d4/d28/ipc__event__queue_8cpp_source.html#l00094">94</a> of file <a class="el" href="../../d4/d28/ipc__event__queue_8cpp_source.html">ipc_event_queue.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ac7c4323062f6246fbf55cde17fa5f6b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * CIPCEventQueue::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current position of the shared memory buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the head of the shared memory buffer </dd></dl>

<p>Definition at line <a class="el" href="../../d4/d28/ipc__event__queue_8cpp_source.html#l00115">115</a> of file <a class="el" href="../../d4/d28/ipc__event__queue_8cpp_source.html">ipc_event_queue.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5726289ba1ba6b35d8ef5d51ae9dae15"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t toolkit::ipc::CIPCEventQueue::chunk_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the maximum data size that can be written to the queue in a single message. </p>
<dl class="section return"><dt>Returns</dt><dd>The maximum chunk size </dd></dl>

<p>Definition at line <a class="el" href="../../d5/d07/ipc__event__queue_8hpp_source.html#l00142">142</a> of file <a class="el" href="../../d5/d07/ipc__event__queue_8hpp_source.html">ipc_event_queue.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9732c7e6ea891726bef6d3ce1b85fcd8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CIPCEventQueue::write </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>msglen</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a new message to the buffer. </p>
<p>The data should have already been written before this call (via the pointer returned by <a class="el" href="../../d3/dcf/classtoolkit_1_1ipc_1_1CIPCEventQueue.html#ac7c4323062f6246fbf55cde17fa5f6b3" title="Get the current position of the shared memory buffer. ">get()</a>); this call merely notifies the other process that the write has taken place. The buffer position (returned by <a class="el" href="../../d3/dcf/classtoolkit_1_1ipc_1_1CIPCEventQueue.html#ac7c4323062f6246fbf55cde17fa5f6b3" title="Get the current position of the shared memory buffer. ">get()</a>) is modified when this call returns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msglen</td><td>The number of bytes written into the buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../dc/d6d/structtoolkit_1_1ipc_1_1generic__err.html" title="Base exception class. ">generic_err</a></td><td>Thrown if the write fails</td></tr>
    <tr><td class="paramname"><a class="el" href="../../dc/dec/structtoolkit_1_1ipc_1_1no__data.html" title="No data is available. ">no_data</a></td><td>Thrown if the queue has reached its size limit (because the reader is not pulling events fast enough to keep pace) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d4/d28/ipc__event__queue_8cpp_source.html#l00127">127</a> of file <a class="el" href="../../d4/d28/ipc__event__queue_8cpp_source.html">ipc_event_queue.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="adb23d3eff81a84372fbdd3eae8869a49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; size_t, bool &gt; CIPCEventQueue::read </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a new message from the buffer. </p>
<p>The data can be read from the buffer returned by <a class="el" href="../../d3/dcf/classtoolkit_1_1ipc_1_1CIPCEventQueue.html#ac7c4323062f6246fbf55cde17fa5f6b3" title="Get the current position of the shared memory buffer. ">get()</a> BEFORE this call is made; after it is made, the buffer will point to the new queue head based on how many bytes were read in this message.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../dc/d6d/structtoolkit_1_1ipc_1_1generic__err.html" title="Base exception class. ">generic_err</a></td><td>Thrown if the read fails</td></tr>
    <tr><td class="paramname"><a class="el" href="../../dc/dec/structtoolkit_1_1ipc_1_1no__data.html" title="No data is available. ">no_data</a></td><td>Thrown if the queue is empty, i.e. there's no data waiting to be read</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first part of the pair is the size of the current message, in bytes. The second part of the pair is true if <a class="el" href="../../d3/dcf/classtoolkit_1_1ipc_1_1CIPCEventQueue.html#adb23d3eff81a84372fbdd3eae8869a49" title="Read a new message from the buffer. ">read()</a> should be called again after the caller is finished reading these bytes. This happens on occasion when there are multiple messages queued up, and they cross over the end of the buffer; in such cases, the first call to <a class="el" href="../../d3/dcf/classtoolkit_1_1ipc_1_1CIPCEventQueue.html#adb23d3eff81a84372fbdd3eae8869a49" title="Read a new message from the buffer. ">read()</a> receives all of the queued messages, as far as the remote client is concerned. Therefore a second call is needed to finish passing the caller the remainder of the messages after looping back around to the beginning of the buffer. Just know that when this boolean returns true, you need to call <a class="el" href="../../d3/dcf/classtoolkit_1_1ipc_1_1CIPCEventQueue.html#adb23d3eff81a84372fbdd3eae8869a49" title="Read a new message from the buffer. ">read()</a> again, regardless of whether or not <a class="el" href="../../d3/dcf/classtoolkit_1_1ipc_1_1CIPCEventQueue.html#acbaa4566c94804ff237cd5c23cfcd9c4" title="Getter for the underlying send/receive FD. ">fd()</a> has data to be read. </dd></dl>

<p>Definition at line <a class="el" href="../../d4/d28/ipc__event__queue_8cpp_source.html#l00186">186</a> of file <a class="el" href="../../d4/d28/ipc__event__queue_8cpp_source.html">ipc_event_queue.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="acbaa4566c94804ff237cd5c23cfcd9c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int toolkit::ipc::CIPCEventQueue::fd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for the underlying send/receive FD. </p>
<dl class="section return"><dt>Returns</dt><dd>The FD used by <a class="el" href="../../d3/dcf/classtoolkit_1_1ipc_1_1CIPCEventQueue.html#adb23d3eff81a84372fbdd3eae8869a49" title="Read a new message from the buffer. ">read()</a> and <a class="el" href="../../d3/dcf/classtoolkit_1_1ipc_1_1CIPCEventQueue.html#a9732c7e6ea891726bef6d3ce1b85fcd8" title="Write a new message to the buffer. ">write()</a> </dd></dl>

<p>Definition at line <a class="el" href="../../d5/d07/ipc__event__queue_8hpp_source.html#l00196">196</a> of file <a class="el" href="../../d5/d07/ipc__event__queue_8hpp_source.html">ipc_event_queue.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6c207fdc4715f3554cdbc62f5990578f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool toolkit::ipc::CIPCEventQueue::is_writer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is this object on the writing / input end of the event queue? </p>
<dl class="section return"><dt>Returns</dt><dd>True if this object writes events to the queue, false if it reads events from the queue </dd></dl>

<p>Definition at line <a class="el" href="../../d5/d07/ipc__event__queue_8hpp_source.html#l00205">205</a> of file <a class="el" href="../../d5/d07/ipc__event__queue_8hpp_source.html">ipc_event_queue.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="ab1ff3c74141d23bde9986d7db18a4123"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char* toolkit::ipc::CIPCEventQueue::_memory</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shared memory segment used for this queue's communication. </p>

<p>Definition at line <a class="el" href="../../d5/d07/ipc__event__queue_8hpp_source.html#l00215">215</a> of file <a class="el" href="../../d5/d07/ipc__event__queue_8hpp_source.html">ipc_event_queue.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afa00761d797965664eaaf85d2f27d59b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t toolkit::ipc::CIPCEventQueue::_capacity</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximum length of this queue, i.e. </p>
<p>the mapped size of _memory </p>

<p>Definition at line <a class="el" href="../../d5/d07/ipc__event__queue_8hpp_source.html#l00220">220</a> of file <a class="el" href="../../d5/d07/ipc__event__queue_8hpp_source.html">ipc_event_queue.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a565ee1b36705c2c9d6fceeb22eb0610a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t toolkit::ipc::CIPCEventQueue::_max_chunk</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The maximum size of a single written chunk, i.e. </p>
<p>a single message </p>

<p>Definition at line <a class="el" href="../../d5/d07/ipc__event__queue_8hpp_source.html#l00225">225</a> of file <a class="el" href="../../d5/d07/ipc__event__queue_8hpp_source.html">ipc_event_queue.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="add5a6d267b009340685f08b6393038da"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t toolkit::ipc::CIPCEventQueue::_write_boundary</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Queue boundary beyond which we force any new messages to wrap-around to the beginning; this is _capacity minus the maximum message size (since we must allow for the last message starting just before this boundary). </p>

<p>Definition at line <a class="el" href="../../d5/d07/ipc__event__queue_8hpp_source.html#l00233">233</a> of file <a class="el" href="../../d5/d07/ipc__event__queue_8hpp_source.html">ipc_event_queue.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a49e9a9ab51a285b3f994bb62cf6a54c2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t toolkit::ipc::CIPCEventQueue::_multiplier</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplier used to align _capacity with the maximum value held in an eventfd() before it blocks; doing this allows us to ensure that upon a queue-full condition, we block until the receiver reads some more data. </p>

<p>Definition at line <a class="el" href="../../d5/d07/ipc__event__queue_8hpp_source.html#l00241">241</a> of file <a class="el" href="../../d5/d07/ipc__event__queue_8hpp_source.html">ipc_event_queue.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abf7cad896fac6d7f1ccb9defa8482ce7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t toolkit::ipc::CIPCEventQueue::_offset</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The current position/offset in the queue (in bytes) </p>

<p>Definition at line <a class="el" href="../../d5/d07/ipc__event__queue_8hpp_source.html#l00246">246</a> of file <a class="el" href="../../d5/d07/ipc__event__queue_8hpp_source.html">ipc_event_queue.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a263fcda6ffabfbab61cb52aafbc1e373"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t toolkit::ipc::CIPCEventQueue::_old_offset</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The oldest in-memory position/offset in the queue (in bytes) </p>

<p>Definition at line <a class="el" href="../../d5/d07/ipc__event__queue_8hpp_source.html#l00251">251</a> of file <a class="el" href="../../d5/d07/ipc__event__queue_8hpp_source.html">ipc_event_queue.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abfd845cdf2ad35b0605412f04eadd6ee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t toolkit::ipc::CIPCEventQueue::_stashed_bytes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of bytes still remaining to be read when an incoming series of messages has been split across the end of the buffer. </p>
<p>See the notes in <a class="el" href="../../d3/dcf/classtoolkit_1_1ipc_1_1CIPCEventQueue.html#adb23d3eff81a84372fbdd3eae8869a49" title="Read a new message from the buffer. ">read()</a> above. This is normally 0, since in the common case we don't need to specially remember that there are more pending bytes. </p>

<p>Definition at line <a class="el" href="../../d5/d07/ipc__event__queue_8hpp_source.html#l00260">260</a> of file <a class="el" href="../../d5/d07/ipc__event__queue_8hpp_source.html">ipc_event_queue.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a89f12be6eb37f4a733c995c03ad36e54"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int toolkit::ipc::CIPCEventQueue::_eventfd</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The eventfd() descriptor used to signal the presence of data to the consumer process. </p>

<p>Definition at line <a class="el" href="../../d5/d07/ipc__event__queue_8hpp_source.html#l00266">266</a> of file <a class="el" href="../../d5/d07/ipc__event__queue_8hpp_source.html">ipc_event_queue.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1a596e516f4a0b76aa04cc79bfa718c5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool toolkit::ipc::CIPCEventQueue::_writer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this object on the write-side of the event queue? </p>

<p>Definition at line <a class="el" href="../../d5/d07/ipc__event__queue_8hpp_source.html#l00271">271</a> of file <a class="el" href="../../d5/d07/ipc__event__queue_8hpp_source.html">ipc_event_queue.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/src/product-ref1/px-toolkit/etn_source/libipc/include/exports/ipc/<a class="el" href="../../d5/d07/ipc__event__queue_8hpp_source.html">ipc_event_queue.hpp</a></li>
<li>/src/product-ref1/px-toolkit/etn_source/libipc/source/<a class="el" href="../../d4/d28/ipc__event__queue_8cpp_source.html">ipc_event_queue.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../dd/dc9/namespacetoolkit.html">toolkit</a></li><li class="navelem"><a class="el" href="../../d0/dc1/namespacetoolkit_1_1ipc.html">ipc</a></li><li class="navelem"><a class="el" href="../../d3/dcf/classtoolkit_1_1ipc_1_1CIPCEventQueue.html">CIPCEventQueue</a></li>
    <li class="footer">Generated on Fri May 7 2021 20:24:44 for libipc by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.8.5 </li>
  </ul>
</div>
</body>
</html>
