<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>IoT Agent: Out-of-Band (OOB) Objects for IoT Agent Configuration and Operation</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../Eaton_Red_Toolbox_Logo.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">IoT Agent
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="../../pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="../../modules.html"><span>Modules</span></a></li>
      <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="../../annotated.html"><span>Classes</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('da/d49/md__src_product-ref1_px-toolkit_etn_source_iot_agent_docs_iot_agent_oobs.html','../../');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Out-of-Band (OOB) Objects for IoT Agent Configuration and Operation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>There are a variety of OOB objects that support the configuration and operation of the IoT Agent daemon (iot_agent):</p>
<ul>
<li>IotConfigSettings</li>
<li>H_IotConnectionString</li>
<li>IotConnectionStatus</li>
<li>ProxySettings</li>
<li>IotDeviceMapping (unused)</li>
<li>IotCatchup</li>
</ul>
<p>In addition, these OOBs for/from the Image Update program(s) are associated with the iot_agent's FirmwareUpdate and Device Command operation:</p>
<ul>
<li>ImageVersion/product/type/version OOBs</li>
<li>ImageUpdate/xxxx</li>
<li>ImageUpdateApp/product</li>
<li>IotDeviceSettings</li>
<li>IotBuiltInCommands/product</li>
</ul>
<p>This OOB handles iot_agent's Blob Upload operation :</p>
<ul>
<li>IotBlobUpload/filename</li>
</ul>
<p>These OOBs are each described in the sections below.</p>
<h2>IotConfigSettings OOB</h2>
<p>The IotConfigSettings OOB provides the configuration information for the IoT Agent (iot_agent) process.</p>
<p>The <a href="../../../rootfs/etc/cds/generic/41_iot_agent_defaults.json">default initialization for IotConfigSettings</a> does not enable the IoT Agent to run; if started, it will quickly recognize this and exit.</p>
<p>The protobuf definition for the IotConfigSettings OOB is found in <a href="../../../../libpx/tk_proto/hg/IotAgentSettings.proto">IotAgentSettings.proto</a>.</p>
<p>The sections below describe how the IotConfigSettings fields are used to support configuration of the IoT Agent. Many of the fields are now deprecated; they were originally thought necessary, but have proved not to be.</p>
<h3>Fields for the IotConfigSettings OOB</h3>
<p>The fields which are used in this OOB are listed individually.</p>
<h4>enabled</h4>
<p>When true, the IoT Agent is enabled to start and operate. The factory default is false, and must be enabled by the owner, if they want IoT access.</p>
<h4>hosted_uri</h4>
<p>Shows the URL for the Azure cloud address that the IoT Agent will attempt to connect to. This field is filled in by the IoT Agent when it processes the connection_string, and is for the convenience of the Net Diagnostics routines (which troubleshoot network issues).</p>
<h4>connection_string</h4>
<p>The owner must write to this field the Connection String for this device, which can be obtained by giving PX White the UUID of this device (at the publisher level) and the adopter and site IDs.</p>
<p>A valid Connection String consists of three parts: the hosted_uri, this device's (publisher) UUID, and a Shared Access Token to authorize the connection.</p>
<p>As soon as this field is written with an (apparently) valid ConnectionString, the IoT Agent code will pull it out of this field, and substitute the text "**Securely Stored**" here. It will copy the Connection String to the hidden OOB, H_IotConnectionString, which only the users with Security Read or Write privileges can view. The reason for hiding the Connection String is to protect the initial Shared Access Token provided in that string, to prevent spoofing a connection from some other device.</p>
<h4>Unused (deprecated) fields</h4>
<p>The following fields are no longer used or of interest: </p>
<pre class="fragment">* protocol
* use_json
* ping_time
* handshake_timeout
* not_tls
</pre><h3>Example of IotConfigSettings OOB</h3>
<p>The following shows an example for an enabled instance of this OOB:</p>
<p>```json { "toolkitStruct": { "iot_agent_settings": { "enabled":true, "hosted_uri":"EatonTestIothub1.azure-devices.net", "protocol":"IOT_TYPE_MQTT", "use_json":true, "ping_time":0, "handshake_timeout":0, "pong_timeout":0, "not_tls":false, "connection_string":"**Securely Stored**" }, "description":"Configuration for the IoT Agent", "label":"IoT Agent Settings" } } ```</p>
<h2>IotConnectionStatus OOB</h2>
<p>The IotConnectionStatus OOB is an OOB whose fields are set by the user (usually through the UI), and it provides Security and User configuration (v1 and/or v3) input to the snmpd.conf file. It also holds the trapsink and trap session information, which must be configured to be useful.</p>
<p>This OOB is accessible by the UI but human access is restricted to Security Admin (for r/w) and Security Viewer (for read-only).</p>
<p>The <a href="../../../snmp_mibs/rootfs/etc/cds/generic/53_snmp_user_defaults.json">default initialization for IotConnectionStatus</a> disables both v1 and v3 access, but also provides the well-known v1 community strings of 'public' and 'private'. Of course, no trapsinks are configured by default.</p>
<p>The protobuf definition for the IotConnectionStatus OOB is found in <a href="../../../../libpx/tk_proto/hg/IotConnectionStatus.proto">IotConnectionStatus.proto</a>.</p>
<h3>IotConnectionStatus OOB fields</h3>
<h4>status</h4>
<p>The status of the connection to the Azure IoT Hub, from the set of IotConnectionStatusEnums. It is IOT_OPEN on success.</p>
<h4>error_state</h4>
<p>A high-level error code for the IoT Agent's connection status, from the set of IotAgentErrorStateEnums. Most useful when the status is Closed, as it then indicates the general reason why. The error_reason text provides fuller details.</p>
<h4>error_reason</h4>
<p>The text here provides the Error Reason details: a human-readable reason for the error (if any).</p>
<h4>last_change_time</h4>
<p>The UTC time (in seconds) of the last change in status. Equivalent to "time_t" in ANSI C, using the UTC timebase of seconds since the Epoch (Jan 1, 1970).</p>
<h4>traffic_count</h4>
<p>A measure of connection traffic, for diagnostic purposes. The traffic_units indicates what is being counted.</p>
<h4>traffic_units</h4>
<p>The units or label for the measure of connection traffic. As shown below, the default is to count the number of messages which have been "confirmed" by Azure.</p>
<h4>log_changes</h4>
<p>The common OOB field is set to false here to prevent the CDS from logging changes in this status OOB (since it changes status frequently when the counts are updated, and is of no special value to log the contents).</p>
<h3>Example of IotConnectionStatus OOB</h3>
<p>The following example shows the status for a failed connection (which is more interesting than for a successful connection).</p>
<p>```json { "toolkitStruct": { "iot_connection_status": { "status":"IOT_CLOSED", "error_state":"IOT_DNS_FAILURE", "error_reason":"DNS Service not responding", "last_change_time":1534537222, "traffic_count":0, "traffic_units":"Messages Confirmed" }, "description":"Status of the IoT Connection", "log_changes":false } } ```</p>
<h2>H_IotConnectionString OOB</h2>
<p>The H_IotConnectionString OOB stores the IoT Connection String that was written to the IotConfigSettings OOB's connection_string field. It is moved to this OOB, which is hidden from most users, to hide the Shared Access Token that is part of that Connection String.</p>
<p>This OOB would accessible by the UI (though there is little reason to do so), but human access is restricted to Security Admin (for r/w) and Security Viewer (for read-only).</p>
<p>The H_IotConnectionString OOB simply uses a single "GenericSettings" string field for its data, as defined in <a href="../../../../libpx/proto/ToolkitConfiguration.proto">ToolkitConfiguration.proto</a>, but then adds the read permissions to tightly restrict access. The write and delete permissions are normal (not overridden here) since the security concern is about revealing the SharedAccessToken to unauthorized parties.</p>
<p>The sections below describe how the H_IotConnectionString fields are used.</p>
<h3>Fields for the H_IotConnectionString OOB</h3>
<h4>generic::StringData</h4>
<p>The IoT Connection String, given as one string of text.</p>
<h4>read_permission_required</h4>
<p>Declares the roles necessary for users (or programs) to be able to read this OOB. Restricted to users with the Security Admin or View privileges.</p>
<h3>Example of H_IotConnectionString OOB, using GenericSettings</h3>
<p>The following example shows this OOB with an (apparently) valid Connection String stored. Note the read permissions, which make this a "hidden" OOB to most users.</p>
<p>```json { "toolkitStruct": { "generic": { "StringData": "HostName=EatonTestIothub1.azure-devices.net; DeviceId=5731bd56-e445-54a1-a217-98e93fa14ba2; SharedAccessKey=Ek9wHX2LX9g65tGGBmJxcpXWJy6qJf3VCZq5UeeLrDQ=" }, "read_permission_required": [ "SECURITY_READ", "INTERNAL_APP", "SECURITY_ADMIN" ] } } ```</p>
<h2>ProxySettings OOB</h2>
<p>This OOB provides the proxy settings for outgoing connections. While in principle useful for other connections, the only current use is for the IoT Agent's outgoing connection to the Azure IoT Hub.</p>
<p>By default, the proxy is disabled.</p>
<p>The protobuf definition for the ProxySettings OOB is found in <a href="../../../../libpx/tk_proto/hg/ProxySettings.proto">ProxySettings.proto</a>.</p>
<h3>Fields for the ProxySettings OOB</h3>
<h4>proxy_enabled</h4>
<p>When true, the IoT must provide these proxy settings when attempting to open an (outgoing) connection to the Azure IoT Hub.</p>
<h4>proxy_address</h4>
<p>Provides the Proxy server address or URI.</p>
<h4>proxy_login_name</h4>
<p>Provides the optional username for authenticating to the Proxy server.</p>
<h4>proxy_password</h4>
<p>Provides the optional password for authenticating to the Proxy server.</p>
<h4>internal_proxy_url (unused)</h4>
<p>This field is currently unused. In the past (ctc_agent), it provided the path for the outgoing agent to use, which was input to the cntlm program; cntlm then provided the proxying services.</p>
<h3>Example 'ProxySettings'</h3>
<p>Proxy settings for inside Eaton corporate networks, when enabled. No username or password are required in this setting (fortunately).</p>
<p>```json { "toolkitStruct": { "proxy_settings": { "proxy_enabled":true, "proxy_address":"https://proxy.etn.com:8080", "proxy_login_name":"", "proxy_password":"", "internal_proxy_url":"http://127.0.0.1:3128/" }, "description":"Proxy Configuration for the outgoing IoT Connection", "label":"Proxy Settings" } } ```</p>
<h2>IotDeviceMapping OOB (unused)</h2>
<p>The IotDeviceMapping OOB was intended to provide a persistent mapping between the IoT Device Profiles and device canonical model names. However, it has not been seen necessary (yet) to implement it.</p>
<p>The protobuf definition for the IotDeviceMapping OOB is found in <a href="../../../../libpx/tk_proto/hg/IotAgentSettings.proto">IotAgentSettings.proto</a>.</p>
<h2>IotCatchup OOB</h2>
<p>This OOB supports Trend Catch-up or "Publish after connection loss".</p>
<p>It persistently records the time of the last successful trend interval publish, and any spans of past time that remain to be published to catch-up PX White to the complete trend records, so there will be no (or, at least, minimal) lost historic data.</p>
<p>The protobuf definition for the IotCatchup OOB is found in <a href="../../../../libpx/tk_proto/hg/IotAgentSettings.proto">IotAgentSettings.proto</a>.</p>
<h3>Fields for the IotCatchup OOB</h3>
<h4>last_trend_published_time</h4>
<p>The timestamp of the last successfully published trend interval, in seconds since the epoch. This will only be updated after all the trend messages for one interval from all devices have been both published and ackowledged.</p>
<h4>trend_catchup_spans</h4>
<p>The list of trend catchup spans (if any) that should be caught up after successfully connecting to the Azure IoT Hub. A span consists of a <code>"begin_span"</code> timestamp, and an <code>"end_span"</code> timestamp, listing the first and the last times which must be published, inclusively.</p>
<p>More than one span entry would mean that a previous catch-up process was interrupted by another connection loss, resulting in additional gaps in the historic data.</p>
<h3>Example 'IotCatchup'</h3>
<p>This example shows one catchup span entry in addition to the last published timestamp. All times are in seconds since the Epoch of Jan 1, 1970.</p>
<p>```json { "toolkitStruct": { "iot_catch_up": { "last_trend_published_time":1576518000, "trend_catchup_spans":[ { "begin_span":1576250100, "end_span":1576250100 } ] }, "description":"Provides data about which records to publish for catch-up", "label":"IoT Catch-up", "log_changes":false, "comments":"No trend_catchup_spans in the default." } } ```</p>
<p>The ImageVersion OOBs provide the version information for the indicated combination of product, image type, and version to the IoT Agent (iot_agent) process. The "image type" is "LinuxImage" for the main product PX Red firmware, but would be something else for other types of device firmware images that have an image update app to support updating their firmware.</p>
<p>There is no default initialization for ImageVersion OOBs; instead, these are created by their image update application with its <code>make_version_oob</code> action, usually at startup.</p>
<p>The protobuf definition for the ImageVersion OOBs is found in <a href="../../../../libpx/tk_proto/hg/ImageUpdate.proto">ImageUpdate.proto</a>.</p>
<p>The sections below describe how the ImageVersion fields are used to describe the version information.</p>
<h3>Fields for the ImageVersion OOBs</h3>
<h4>device_ids</h4>
<p>A list of one or more CDS Device IDs covered by this Image Version OOB. All listed Devices must have the same version information; otherwise, another ImageVersion with a different version in the name should be added.</p>
<h4>addl_capabilities</h4>
<p>The set of flags which indicate additional capabilities that the target device is capable of (eg, the Reboot command), besides Image Updating, via its Image Update application.</p>
<p>This value is composed of one or more of the AdditionalCapabilitiesFlags values, OR'd together.</p>
<h4>image_update_app</h4>
<p>The name of the Image Update application to be invoked to manage the various Image Update actions, and to provide the necessary OOB data.</p>
<h4>images</h4>
<p>A array of ImageEntry structures. There may be multiple ImageEntries listed for this set of device_ids. The following section shows the fields for the ImageEntry structure.</p>
<h4>Fields for the ImageEntry structure</h4>
<h5>image_name</h5>
<p>The name for this type of Image entry. This will be compared to that in any firmware update package to determine suitability of the upgrade.</p>
<h5>image_version</h5>
<p>The present Image version (eg, firmware revision). The Image Update application for this Image will compare this version to that in an image update, to determine whether to allow the update.</p>
<h5>board_name</h5>
<p>Hardware name or type (eg, board name) for this Image. May be helpful when determining compatibility with new Images.</p>
<h5>board_version</h5>
<p>Hardware version (eg, board revision) for this Image. May be helpful when determining compatibility with new Images.</p>
<h5>update_constraints</h5>
<p>Flags for Upgrade Limitations / Constraints. This value is composed of one or more of the ImageUpdateConstraintFlags values, OR'd together.</p>
<h5>image_version_details</h5>
<p>Additional details for the present Image version, for human, not machine, consumption. This might be a long version ID not suitable for machine processing, designatin as "Beta" or "RCx" version, etc).</p>
<h5>component_details</h5>
<p>Additional Version information for components in this Image, one per line. For human, not machine, consumption, these entries list version information for major components within the Image (eg, Toolkit, UI, or library versions). Each component described should get a separate line.</p>
<h3>Example 'ImageVersion/PX-Red-BBB/LinuxImage/RI-10-278'</h3>
<p>This example shows the ImageVersion OOB for a BBB's LinuxImage at version RI-10-278; this product/image type/version pattern will be used for all OOBs generated by the image update app.</p>
<p>```json { "toolkitStruct": { "image_version": { "device_ids": [ 1 ], "images": [ { "image_name":"LinuxImage", "image_version":"RI-10-278", "board_name":"Architecture: arm  Board: bbblack", "board_version":"Cpu: ARMv7 Processor rev 2 (v7l)  ", "update_constraints":8, "image_version_details":"RI-10-278-g916b993", "component_details": [ "PX Red Toolkit: 3.18.6", "Linux Kernel: 4.14.51", "GCC Compiler: arm-cortexa8-linux-gnueabi-gcc (GCC) 4.9.4", "Build Date: 08/22/18 16:06" ] } ], "addl_capabilities":1, "image_update_app":"update_linux_image" } } } ```</p>
<h2>ImageUpdate/xxxx OOBs</h2>
<p>The ImageUpdate/xxxx OOBs are non-persistent status OOBs which are actually produced by the image update apps (eg, update_linux_image).</p>
<p>These image update apps are usually invoked by the IoT Agent (iot_agent) process. If the image update app is invoked by the IoT Agent, that Agent will provide the full tag name for the OOB and then subscribe to updates in that OOB. The firmware update app will generally update this OOB at each "step" (however it is that the app defines a step), and the IoT Agent will then push this information as a status update to Azure.</p>
<p>There is no default initialization for ImageVersion OOBs; instead, these are created by their image update application with its <code>update</code> action.</p>
<p>The protobuf definition for the ImageUpdate OOBs is found in <a href="../../../../libpx/tk_proto/hg/ImageUpdate.proto">ImageUpdate.proto</a>.</p>
<p>The sections below describe how the ImageUpdate fields are used to indicate the status of an update process for the IoT Agent.</p>
<h3>Fields for the ImageUpdate/xxxx OOBs</h3>
<h4>last_image_name</h4>
<p>The Image name or type currently being processed, or the last Image type acted upon when the process completes.</p>
<h4>last_device_id</h4>
<p>The CDS Device ID of the Device currently being updated, or of the last Device acted upon when the process completes.</p>
<h4>step_name</h4>
<p>A name for the step currently being carried out, or the final step when the process completes through success or failure.</p>
<h4>step_number</h4>
<p>The number of the current step, within the expected series of steps.</p>
<h4>exp_total_steps</h4>
<p>The estimate of the total number of steps to complete the Image Update for all devices and all Image types.</p>
<h4>update_status</h4>
<p>The overall status of the Update, up to this point. This will be one of the enums from the set of ImageUpdateStatusEnums.</p>
<h4>successes and failures</h4>
<p>Each is a list of the Image Update successes or failures, per Device + Image type. Each entry is of the DeviceImageResult structure, which consist of the following fields.</p>
<h4>Fields for the DeviceImageResult entries</h4>
<h5>image_name</h5>
<p>The name or type of the Image for this report.</p>
<h5>device_id</h5>
<p>The Device ID of the Device for this report.</p>
<h5>step_name</h5>
<p>The name for the (final) step at which the process failed. Not provided in success entries.</p>
<h5>failure_reason</h5>
<p>Image Update Failure reason: Provides a human-readable reason for the failure of this Device + Image type Update. Not provided in success entries.</p>
<h3>Example 'ImageUpdate/xxxx'</h3>
<p>This example was captured at the (successful) end of a FirmwareUpdate for the LinuxImage.</p>
<p>```json { "toolkitStruct": { "image_update_results": { "last_image_name":"LinuxImage", "last_device_id":1, "step_name":"script", "update_status":"UPDATE_STATUS_DONE_SUCCESS", "successes": [ { "image_name":"LinuxImage", "device_id":1 } ], "step_number":3, "exp_total_steps":3 } } } ```</p>
<h2>ImageUpdateApp OOBs</h2>
<p>The ImageUpdateApp/product OOBs provide a mapping of the Image Update App names to device models for use when a new device is added to the system and its Image Update App must be called for the "make_version_oob" action to add this device to the correct ImageVersion/product/type/version OOB.</p>
<p>The default initialization for ImageUpdateApp OOBs are normally set at the product level, since it is up to the product to map the device models to their supporting Image Update apps. There may be more than one ImageUpdateApp OOB, as there may be a number of device models supported.</p>
<p>The ImageUpdateApp OOBs use the GenericTableEntry type, as described in <a href="../../../../libpx/tk_proto/hg/GenericTableEntry.proto">GenericTableEntry.proto</a>.</p>
<p>The sections below describe how the GenericTableEntry fields are used in the ImageUpdateApp OOBs.</p>
<h3>Fields for the ImageUpdateApp OOBs, using GenericTableEntry</h3>
<h4>label</h4>
<p>This must specify the device canonical model name.</p>
<h4>description</h4>
<p>Text to describe this entry.</p>
<h4>value</h4>
<p>This must be a string ("str_val") naming the Image Update app to be used for this model.</p>
<h4>read_permission_required</h4>
<p>Can be specified to limit the access to an OOB. In this case, it is not because it is secure information, but because we don't want the UI to show it.</p>
<h3>Example 'ImageUpdateApp/Ephesus'</h3>
<p>This example was captured from the Ephesus ProGateway build, and shows one entry for the lighting fixtures' Image Update app.</p>
<p>```json { "toolkitStruct": { "label":"Ephesus ImageUpdate apps", "description":"Assignment of model-specific image update app(s). Model name in label field, app name as the value.", "generic_table": [ { "description": "Image Update app for GameOn400 devices", "value": { "str_val": "update_gameon_images" }, "label": "GameOn400" } ], "read_permission_required":["INTERNAL_APP","PER_USER"] } } ```</p>
<h2>IotDeviceSettings OOB</h2>
<p>The IotDeviceSettings OOB provides persistent IoT Device configuration information for the IoT Agent (iot_agent) process. For example, this OOB records which devices have had the "special" channels for RealtimesDisabled or TrendsDisabled set.</p>
<p>There is no default initialization for IotDeviceSettings OOB; instead, these are created by TBD.</p>
<p>The protobuf definition for the IotDeviceSettings OOB is a repeated list (ie, array) of the GenericDeviceSettingsEntry found in <a href="../../../../libpx/tk_proto/hg/GenericTableEntry.proto">GenericTableEntry.proto</a>.</p>
<p>The sections below describe how the IotDeviceSettings fields are used to support configuration of the IoT Agent.</p>
<h3>Fields for the IotDeviceSettings OOB, using GenericDeviceSettingsEntry</h3>
<p>This OOB consists of a repeated list of GenericDeviceSettingsEntries, one per device with IoT settings that need to be persisted.</p>
<p>The following fields are used in this structure:</p>
<h4>cds_id</h4>
<p>The CDS Device or Channel ID for this entry's data.</p>
<h4>settings</h4>
<p>The array of settings (GenericTableEntry structures) data (the label and value fields mostly, with the optional description field). The description field might be repurposed for "additional details" or path to the setting.</p>
<h3>Example 'IotDeviceSettings'</h3>
<p>This example was captured during the iot_agent_test (Unit test), so it is a somewhat artificial example, but does illustrate the usage of this OOB. It shows a setting of one of the "special" built-in "channels", trendsDisabled, for the publisher device, with its non-default value of "true".</p>
<p>```json { "toolkitStruct": { "generic_dev_settings_table": [ { "cds_id":1, "settings": [ { "label":"trendsDisabled", "value": { "str_val":"true" } } ] } ] } } ```</p>
<h2>IotBuiltInCommands OOBs</h2>
<p>The IotBuiltInCommands/product OOBs provide the usage and availability information for IoT Generic Device Commands for the IoT Agent (iot_agent) process.</p>
<p>The default initialization for IotBuiltInCommands OOBs are normally set at the product level, since it is up to the product to determine which Built-In commands should be available. There may be more than one IotBuiltInCommands OOB, as the supported commands may come from different areas of the product.</p>
<p>The IotBuiltInCommands OOBs use the GenericTableEntry type, as described in <a href="../../../../libpx/tk_proto/hg/GenericTableEntry.proto">GenericTableEntry.proto</a>.</p>
<p>The sections below describe how the GenericTableEntry fields are used in the IotBuiltInCommands OOBs.</p>
<h3>Fields for the IotBuiltInCommands OOBs, using GenericTableEntry</h3>
<h4>label</h4>
<p>This must specify the "method" name for the IoT Generic Device Command. Only methods explicitly listed in IotBuiltInCommands OOBs will allowed to execute as IoT Generic Device Commands (besides the hard-coded commands like GetChannels and SetChannels).</p>
<h4>description</h4>
<p>Text to describe the commmand entry.</p>
<h4>value</h4>
<p>This must be a string ("str_val") naming the app or script to be executed for this method. The string can contain fixed arguments as well as the app or script name.</p>
<h4>comments</h4>
<p>The text here can describe any additional arguments that will be provided as the "parameters" of the IoT Generic Device Command, and the results returned.</p>
<h3>Example 'IotBuiltInCommands/kvm'</h3>
<p>This example was captured from the product-test KVM build, and shows three entries for built-in commands.</p>
<p>```json { "toolkitStruct": { "generic_table": [ { "label":"SetField", "description":"Supported built in set field device command", "value": { "str_val":"cdscmd -sf" }, "comments": "The args parameter must be a string with the fieldname and new value." }, { "label":"GetField", "description":"Supported built in get field device command", "value": { "str_val":"cdscmd -gf" }, "comments": "The args parameter must be a string with the fieldname; the value will be returned." }, { "label":"CdsCmd", "description":"Built in support to run cdscmd", "value": { "str_val":"cdscmd" }, "comments": "The args parameter must be a string with the rest of the command line; the results will be returned." } ], "description":"Iot agent built in device commands for read and write", "label":"Built In Device Commands for KVM" } } ```</p>
<h2>IotBlobUpload OOB</h2>
<p>There is no default initialization for IotBlobUpload OOB, these are created by the application dynamically as per need to upload a file.</p>
<p>The application is responsible for creating a new OOB for each file to be uploaded. The OOB tag will have the format as IotBlobUpload/xxx where xxx will be the file name of file to be uploaded.</p>
<p>The IoT agent will read the request from from and write the response to the OOB. The product will be responsible for deleting the OOB as required by them.</p>
<p>IotBlobUpload OOB can be divided in two sections IotBlobUploadRequest and IotBlobUploadResponse.</p>
<p>IotBlobUploadRequest contains device id, blob type, timestamp, relative file path for each of the files.</p>
<p>IotBlobUploadResponse contains result enum, blob path, response message and retry count.</p>
<p>OOB description in <a href="https://confluence-prod.tcc.etn.com/display/LNXTK/IoT+Blob+Upload+Design">https://confluence-prod.tcc.etn.com/display/LNXTK/IoT+Blob+Upload+Design</a>. Sample OOB with request and response after upload: ```json { "toolkitStruct": { "iot_blob_upload": { "blob_up_request": { "device_id":1, "filepath":"blob/batterydata.csv", "blobtype":"blobs" }, "blob_up_response": { "result":"IOT_BLOB_UPLOAD_DONE_SUCCESS", "resp_msg":"Successfully uploaded the file blob/batterydata.csv.", "retry_count":1, "blob_path":"1d1e8f9e-fd5a-5afc-a28b-aa41ac87d312/blobs/2020-07-14/14-07-45-312" } } } } ``` </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri May 7 2021 20:26:03 for IoT Agent by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.8.5 </li>
  </ul>
</div>
</body>
</html>
