<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>cds_ng: CThreadBaseQueue Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">cds_ng
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classCThreadBaseQueue.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classCThreadBaseQueue-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">CThreadBaseQueue Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class collects a list of pending commands/responses to be performed by the worker thread.  
 <a href="classCThreadBaseQueue.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="thread__base__queue_8hpp_source.html">thread_base_queue.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for CThreadBaseQueue:</div>
<div class="dyncontent">
<div class="center"><img src="classCThreadBaseQueue__inherit__graph.png" border="0" usemap="#CThreadBaseQueue_inherit__map" alt="Inheritance graph"/></div>
<map name="CThreadBaseQueue_inherit__map" id="CThreadBaseQueue_inherit__map">
<area shape="rect" id="node2" href="classCThreadCommandQueue.html" title="This class collects a prioritized list of pending operations to be performed by the worker thread..." alt="" coords="5,80,189,107"/><area shape="rect" id="node3" href="classCThreadResponseQueue.html" title="This class collects a prioritized list of pending operations to be performed by the worker thread..." alt="" coords="214,80,393,107"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for CThreadBaseQueue:</div>
<div class="dyncontent">
<div class="center"><img src="classCThreadBaseQueue__coll__graph.png" border="0" usemap="#CThreadBaseQueue_coll__map" alt="Collaboration graph"/></div>
<map name="CThreadBaseQueue_coll__map" id="CThreadBaseQueue_coll__map">
<area shape="rect" id="node3" title="STL class. " alt="" coords="33,5,161,32"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCThreadBaseQueue_1_1timed__out.html">timed_out</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This exception is used to indicate that a timeout was reached while waiting for new commands/responses to be added to the queue.  <a href="structCThreadBaseQueue_1_1timed__out.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a878d987cab9a76f5dd0e134cde93ebb5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a878d987cab9a76f5dd0e134cde93ebb5"></a>
typedef std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="classCThreadCommand.html">CThreadCommand</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCThreadBaseQueue.html#a878d987cab9a76f5dd0e134cde93ebb5">cmd_ptr_t</a></td></tr>
<tr class="memdesc:a878d987cab9a76f5dd0e134cde93ebb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to a [polymorphic] thread command object. <br/></td></tr>
<tr class="separator:a878d987cab9a76f5dd0e134cde93ebb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac42613c03efbfcfa1871c15de3aafb91"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac42613c03efbfcfa1871c15de3aafb91"></a>
typedef std::deque&lt; <a class="el" href="classCThreadBaseQueue.html#a878d987cab9a76f5dd0e134cde93ebb5">cmd_ptr_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCThreadBaseQueue.html#ac42613c03efbfcfa1871c15de3aafb91">cmdlist_t</a></td></tr>
<tr class="memdesc:ac42613c03efbfcfa1871c15de3aafb91"><td class="mdescLeft">&#160;</td><td class="mdescRight">A collection of thread command/response objects, in preserved FIFO ordering. <br/></td></tr>
<tr class="separator:ac42613c03efbfcfa1871c15de3aafb91"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af44f668db7e5b2aa8c5c31a5208f9477"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCThreadBaseQueue.html#af44f668db7e5b2aa8c5c31a5208f9477">CThreadBaseQueue</a> (size_t max_capacity)</td></tr>
<tr class="memdesc:af44f668db7e5b2aa8c5c31a5208f9477"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#af44f668db7e5b2aa8c5c31a5208f9477">More...</a><br/></td></tr>
<tr class="separator:af44f668db7e5b2aa8c5c31a5208f9477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19f1f5c07fd15a11feb8b88961b3224b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a19f1f5c07fd15a11feb8b88961b3224b"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCThreadBaseQueue.html#a19f1f5c07fd15a11feb8b88961b3224b">~CThreadBaseQueue</a> ()</td></tr>
<tr class="memdesc:a19f1f5c07fd15a11feb8b88961b3224b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr class="separator:a19f1f5c07fd15a11feb8b88961b3224b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6590025241e6892ababc2d982d9a0bb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classCThreadBaseQueue.html#ac42613c03efbfcfa1871c15de3aafb91">cmdlist_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCThreadBaseQueue.html#ae6590025241e6892ababc2d982d9a0bb">remove</a> (const px::CTimestamp &amp;timeout=px::CTimestamp())</td></tr>
<tr class="memdesc:ae6590025241e6892ababc2d982d9a0bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dequeue all commands/responses from the queue.  <a href="#ae6590025241e6892ababc2d982d9a0bb">More...</a><br/></td></tr>
<tr class="separator:ae6590025241e6892ababc2d982d9a0bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fb4074f8b504fcc9fc3e0ba589959f0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCThreadBaseQueue.html#a0fb4074f8b504fcc9fc3e0ba589959f0">add</a> (<a class="el" href="classCThreadBaseQueue.html#a878d987cab9a76f5dd0e134cde93ebb5">cmd_ptr_t</a> &amp;&amp;cmd, bool move_to_head=false)</td></tr>
<tr class="memdesc:a0fb4074f8b504fcc9fc3e0ba589959f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a command to the queue.  <a href="#a0fb4074f8b504fcc9fc3e0ba589959f0">More...</a><br/></td></tr>
<tr class="separator:a0fb4074f8b504fcc9fc3e0ba589959f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a341fc833031e7aefd895a4c81822582c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCThreadBaseQueue.html#a341fc833031e7aefd895a4c81822582c">add</a> (<a class="el" href="classCThreadBaseQueue.html#ac42613c03efbfcfa1871c15de3aafb91">cmdlist_t</a> &amp;&amp;cmds, bool move_to_head=false)</td></tr>
<tr class="memdesc:a341fc833031e7aefd895a4c81822582c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add multiple commands to the queue.  <a href="#a341fc833031e7aefd895a4c81822582c">More...</a><br/></td></tr>
<tr class="separator:a341fc833031e7aefd895a4c81822582c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:af467edac9b9e89925b1c5f7d1fb21429"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af467edac9b9e89925b1c5f7d1fb21429"></a>
typedef boost::unique_lock<br class="typebreak"/>
&lt; boost::mutex &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCThreadBaseQueue.html#af467edac9b9e89925b1c5f7d1fb21429">queue_lock_t</a></td></tr>
<tr class="memdesc:af467edac9b9e89925b1c5f7d1fb21429"><td class="mdescLeft">&#160;</td><td class="mdescRight">A lock type used for mutex control. <br/></td></tr>
<tr class="separator:af467edac9b9e89925b1c5f7d1fb21429"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ad37892083d62edb804561ce3156dee5c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCThreadBaseQueue.html#ad37892083d62edb804561ce3156dee5c">full_queue</a> ()</td></tr>
<tr class="memdesc:ad37892083d62edb804561ce3156dee5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the queue is full.  <a href="#ad37892083d62edb804561ce3156dee5c">More...</a><br/></td></tr>
<tr class="separator:ad37892083d62edb804561ce3156dee5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adee2308478888ebb5bd6482e9e11497b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCThreadBaseQueue.html#ac42613c03efbfcfa1871c15de3aafb91">cmdlist_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCThreadBaseQueue.html#adee2308478888ebb5bd6482e9e11497b">remove_impl</a> (const px::CTimestamp &amp;timeout, <a class="el" href="classCThreadBaseQueue.html#af467edac9b9e89925b1c5f7d1fb21429">queue_lock_t</a> *plock)</td></tr>
<tr class="memdesc:adee2308478888ebb5bd6482e9e11497b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dequeue all commands/responses from the queue.  <a href="#adee2308478888ebb5bd6482e9e11497b">More...</a><br/></td></tr>
<tr class="separator:adee2308478888ebb5bd6482e9e11497b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaff1fad9a57494cf93bf57a58231b37d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aaff1fad9a57494cf93bf57a58231b37d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCThreadBaseQueue.html#aaff1fad9a57494cf93bf57a58231b37d">add_impl</a> (T &amp;&amp;cmds, <a class="el" href="classCThreadBaseQueue.html#af467edac9b9e89925b1c5f7d1fb21429">queue_lock_t</a> *plock, bool move_to_head)</td></tr>
<tr class="memdesc:aaff1fad9a57494cf93bf57a58231b37d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add command(s) to the queue.  <a href="#aaff1fad9a57494cf93bf57a58231b37d">More...</a><br/></td></tr>
<tr class="separator:aaff1fad9a57494cf93bf57a58231b37d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac840c7e7b38eb6407d7d97f5984dba36"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac840c7e7b38eb6407d7d97f5984dba36"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCThreadBaseQueue.html#ac840c7e7b38eb6407d7d97f5984dba36">enqueue</a> (T &amp;&amp;cmds, bool move_to_head)</td></tr>
<tr class="memdesc:ac840c7e7b38eb6407d7d97f5984dba36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert the given commands into the queue.  <a href="#ac840c7e7b38eb6407d7d97f5984dba36">More...</a><br/></td></tr>
<tr class="separator:ac840c7e7b38eb6407d7d97f5984dba36"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:af594d9c903c78183c418e1bf05a13598"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af594d9c903c78183c418e1bf05a13598"></a>
<a class="el" href="classCThreadBaseQueue.html#ac42613c03efbfcfa1871c15de3aafb91">cmdlist_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCThreadBaseQueue.html#af594d9c903c78183c418e1bf05a13598">_queue</a></td></tr>
<tr class="memdesc:af594d9c903c78183c418e1bf05a13598"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal FIFO queue of pending commands/responses. <br/></td></tr>
<tr class="separator:af594d9c903c78183c418e1bf05a13598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23f6c9a0496f840db8670228c4144192"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a23f6c9a0496f840db8670228c4144192"></a>
boost::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCThreadBaseQueue.html#a23f6c9a0496f840db8670228c4144192">_mutex</a></td></tr>
<tr class="memdesc:a23f6c9a0496f840db8670228c4144192"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex for synchronizing access to _queue. <br/></td></tr>
<tr class="separator:a23f6c9a0496f840db8670228c4144192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b42a278890a4e4c06da83cf2d7efb8f"><td class="memItemLeft" align="right" valign="top">boost::condition_variable&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCThreadBaseQueue.html#a2b42a278890a4e4c06da83cf2d7efb8f">_cond</a></td></tr>
<tr class="memdesc:a2b42a278890a4e4c06da83cf2d7efb8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Condition variable used to signal the arrival of new data in _queue.  <a href="#a2b42a278890a4e4c06da83cf2d7efb8f">More...</a><br/></td></tr>
<tr class="separator:a2b42a278890a4e4c06da83cf2d7efb8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ee33dadd7dc4d2848ff58ab90e57cde"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCThreadBaseQueue.html#a5ee33dadd7dc4d2848ff58ab90e57cde">_max_capacity</a></td></tr>
<tr class="memdesc:a5ee33dadd7dc4d2848ff58ab90e57cde"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum size that _queue can ever grow to before we block and wait for the worker thread to flush it out.  <a href="#a5ee33dadd7dc4d2848ff58ab90e57cde">More...</a><br/></td></tr>
<tr class="separator:a5ee33dadd7dc4d2848ff58ab90e57cde"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class collects a list of pending commands/responses to be performed by the worker thread. </p>

<p>Definition at line <a class="el" href="thread__base__queue_8hpp_source.html#l00018">18</a> of file <a class="el" href="thread__base__queue_8hpp_source.html">thread_base_queue.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="af44f668db7e5b2aa8c5c31a5208f9477"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CThreadBaseQueue::CThreadBaseQueue </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_capacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_capacity</td><td>The maximum allowable size of the internal queue. If an attempt is made to add more items once the queue has reached this size, the caller will be blocked until the receiving thread removes the existing items. 0 indicates "no limit". </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="thread__base__queue_8cpp_source.html#l00010">10</a> of file <a class="el" href="thread__base__queue_8cpp_source.html">thread_base_queue.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ae6590025241e6892ababc2d982d9a0bb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCThreadBaseQueue.html#ac42613c03efbfcfa1871c15de3aafb91">CThreadBaseQueue::cmdlist_t</a> CThreadBaseQueue::remove </td>
          <td>(</td>
          <td class="paramtype">const px::CTimestamp &amp;&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>px::CTimestamp()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dequeue all commands/responses from the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>The maximum amount of time to wait before returning (a default/invalid timestamp will block indefinitely).</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structCThreadBaseQueue_1_1timed__out.html" title="This exception is used to indicate that a timeout was reached while waiting for new commands/response...">timed_out</a></td><td>Thrown if the timeout is exceeded</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>All pending commands/responses </dd></dl>

<p>Reimplemented in <a class="el" href="classCThreadResponseQueue.html#a342c8d88e75fc57f36f2546a1cd7ad26">CThreadResponseQueue</a>.</p>

<p>Definition at line <a class="el" href="thread__base__queue_8cpp_source.html#l00027">27</a> of file <a class="el" href="thread__base__queue_8cpp_source.html">thread_base_queue.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0fb4074f8b504fcc9fc3e0ba589959f0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CThreadBaseQueue::add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCThreadBaseQueue.html#a878d987cab9a76f5dd0e134cde93ebb5">cmd_ptr_t</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>move_to_head</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a command to the queue. </p>
<p>This call adds the given command to the queue. If the queue is full already (based on the max capacity as configured at construction), the caller is blocked until the receiving thread calls <a class="el" href="classCThreadBaseQueue.html#ae6590025241e6892ababc2d982d9a0bb" title="Dequeue all commands/responses from the queue. ">remove()</a>. Note that this is only needed in extreme circumstances (heavy load, stress-test, etc.) to prevent the queue from growing indefinitely.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmd</td><td>The command/response to be inserted into the internal queue</td></tr>
    <tr><td class="paramname">move_to_head</td><td>If true, this command is inserted at the head of the queue, so that it will be executed in front of already-present commands </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classCThreadResponseQueue.html#a9923da048fd879b5dae6c736df39c0c5">CThreadResponseQueue</a>.</p>

<p>Definition at line <a class="el" href="thread__base__queue_8cpp_source.html#l00037">37</a> of file <a class="el" href="thread__base__queue_8cpp_source.html">thread_base_queue.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a341fc833031e7aefd895a4c81822582c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CThreadBaseQueue::add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCThreadBaseQueue.html#ac42613c03efbfcfa1871c15de3aafb91">cmdlist_t</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>cmds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>move_to_head</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add multiple commands to the queue. </p>
<p>This call adds the given commands to the queue. If the queue is full already (based on the max capacity as configured at construction), the caller is blocked until the receiving thread calls <a class="el" href="classCThreadBaseQueue.html#ae6590025241e6892ababc2d982d9a0bb" title="Dequeue all commands/responses from the queue. ">remove()</a>. Note that this is only needed in extreme circumstances (heavy load, stress-test, etc.) to prevent the queue from growing indefinitely.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmds</td><td>The commands/responses to be inserted into the internal queue</td></tr>
    <tr><td class="paramname">move_to_head</td><td>If true, this command is inserted at the head of the queue, so that it will be executed in front of already-present commands </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classCThreadResponseQueue.html#a04a31dbf954039c9ed90ed5b6465590f">CThreadResponseQueue</a>.</p>

<p>Definition at line <a class="el" href="thread__base__queue_8cpp_source.html#l00048">48</a> of file <a class="el" href="thread__base__queue_8cpp_source.html">thread_base_queue.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad37892083d62edb804561ce3156dee5c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CThreadBaseQueue::full_queue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the queue is full. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the queue is already at or beyond capacity, and therefore <a class="el" href="classCThreadBaseQueue.html#a0fb4074f8b504fcc9fc3e0ba589959f0" title="Add a command to the queue. ">add()</a> should block until another thread does a <a class="el" href="classCThreadBaseQueue.html#ae6590025241e6892ababc2d982d9a0bb" title="Dequeue all commands/responses from the queue. ">remove()</a> first. </dd></dl>

<p>Definition at line <a class="el" href="thread__base__queue_8cpp_source.html#l00059">59</a> of file <a class="el" href="thread__base__queue_8cpp_source.html">thread_base_queue.cpp</a>.</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classCThreadBaseQueue_ad37892083d62edb804561ce3156dee5c_icgraph.png" border="0" usemap="#classCThreadBaseQueue_ad37892083d62edb804561ce3156dee5c_icgraph" alt=""/></div>
<map name="classCThreadBaseQueue_ad37892083d62edb804561ce3156dee5c_icgraph" id="classCThreadBaseQueue_ad37892083d62edb804561ce3156dee5c_icgraph">
<area shape="rect" id="node2" href="classCThreadBaseQueue.html#adee2308478888ebb5bd6482e9e11497b" title="Dequeue all commands/responses from the queue. " alt="" coords="233,64,477,91"/><area shape="rect" id="node5" href="classCThreadBaseQueue.html#aaff1fad9a57494cf93bf57a58231b37d" title="Add command(s) to the queue. " alt="" coords="245,123,464,149"/><area shape="rect" id="node3" href="classCThreadBaseQueue.html#ae6590025241e6892ababc2d982d9a0bb" title="Dequeue all commands/responses from the queue. " alt="" coords="528,5,736,32"/><area shape="rect" id="node4" href="classCThreadResponseQueue.html#a342c8d88e75fc57f36f2546a1cd7ad26" title="Dequeue all commands/responses from the queue. " alt="" coords="542,57,722,98"/><area shape="rect" id="node6" href="classCThreadBaseQueue.html#a0fb4074f8b504fcc9fc3e0ba589959f0" title="Add a command to the queue. " alt="" coords="541,123,723,149"/><area shape="rect" id="node7" href="classCThreadResponseQueue.html#a9923da048fd879b5dae6c736df39c0c5" title="Add a command to the queue. " alt="" coords="526,173,738,200"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="adee2308478888ebb5bd6482e9e11497b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCThreadBaseQueue.html#ac42613c03efbfcfa1871c15de3aafb91">CThreadBaseQueue::cmdlist_t</a> CThreadBaseQueue::remove_impl </td>
          <td>(</td>
          <td class="paramtype">const px::CTimestamp &amp;&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCThreadBaseQueue.html#af467edac9b9e89925b1c5f7d1fb21429">queue_lock_t</a> *&#160;</td>
          <td class="paramname"><em>plock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dequeue all commands/responses from the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>The maximum amount of time to wait before returning (a default/invalid timestamp will block indefinitely).</td></tr>
    <tr><td class="paramname">plock</td><td>If non-NULL, this must point to a lock which has ownership of _mutex. Otherwise the call will acquire its own lock internally.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structCThreadBaseQueue_1_1timed__out.html" title="This exception is used to indicate that a timeout was reached while waiting for new commands/response...">timed_out</a></td><td>Thrown if the timeout is exceeded</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>All pending commands/responses </dd></dl>

<p>Definition at line <a class="el" href="thread__base__queue_8cpp_source.html#l00074">74</a> of file <a class="el" href="thread__base__queue_8cpp_source.html">thread_base_queue.cpp</a>.</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classCThreadBaseQueue_adee2308478888ebb5bd6482e9e11497b_icgraph.png" border="0" usemap="#classCThreadBaseQueue_adee2308478888ebb5bd6482e9e11497b_icgraph" alt=""/></div>
<map name="classCThreadBaseQueue_adee2308478888ebb5bd6482e9e11497b_icgraph" id="classCThreadBaseQueue_adee2308478888ebb5bd6482e9e11497b_icgraph">
<area shape="rect" id="node2" href="classCThreadBaseQueue.html#ae6590025241e6892ababc2d982d9a0bb" title="Dequeue all commands/responses from the queue. " alt="" coords="299,5,507,32"/><area shape="rect" id="node3" href="classCThreadResponseQueue.html#a342c8d88e75fc57f36f2546a1cd7ad26" title="Dequeue all commands/responses from the queue. " alt="" coords="313,57,493,98"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="aaff1fad9a57494cf93bf57a58231b37d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">template void CThreadBaseQueue::add_impl </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>cmds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCThreadBaseQueue.html#af467edac9b9e89925b1c5f7d1fb21429">queue_lock_t</a> *&#160;</td>
          <td class="paramname"><em>plock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>move_to_head</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add command(s) to the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmds</td><td>A [list of] command(s) to add to the queue</td></tr>
    <tr><td class="paramname">plock</td><td>If non-NULL, this must point to a lock which has ownership of _mutex. Otherwise the call will acquire its own lock internally.</td></tr>
    <tr><td class="paramname">move_to_head</td><td>If true, this command is inserted at the head of the queue, so that it will be executed in front of already-present commands </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="thread__base__queue_8cpp_source.html#l00131">131</a> of file <a class="el" href="thread__base__queue_8cpp_source.html">thread_base_queue.cpp</a>.</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classCThreadBaseQueue_aaff1fad9a57494cf93bf57a58231b37d_icgraph.png" border="0" usemap="#classCThreadBaseQueue_aaff1fad9a57494cf93bf57a58231b37d_icgraph" alt=""/></div>
<map name="classCThreadBaseQueue_aaff1fad9a57494cf93bf57a58231b37d_icgraph" id="classCThreadBaseQueue_aaff1fad9a57494cf93bf57a58231b37d_icgraph">
<area shape="rect" id="node2" href="classCThreadBaseQueue.html#a0fb4074f8b504fcc9fc3e0ba589959f0" title="Add a command to the queue. " alt="" coords="287,5,470,32"/><area shape="rect" id="node3" href="classCThreadResponseQueue.html#a9923da048fd879b5dae6c736df39c0c5" title="Add a command to the queue. " alt="" coords="273,56,485,83"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ac840c7e7b38eb6407d7d97f5984dba36"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CThreadBaseQueue::enqueue </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>cmds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>move_to_head</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert the given commands into the queue. </p>
<p>This is the underlying template function used by <a class="el" href="classCThreadBaseQueue.html#aaff1fad9a57494cf93bf57a58231b37d" title="Add command(s) to the queue. ">add_impl()</a> which is specialized for each supported type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmds</td><td>A [list of] command(s) to add to the queue</td></tr>
    <tr><td class="paramname">move_to_head</td><td>If true, this command is inserted at the head of the queue, so that it will be executed in front of already-present commands </td></tr>
  </table>
  </dd>
</dl>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classCThreadBaseQueue_ac840c7e7b38eb6407d7d97f5984dba36_icgraph.png" border="0" usemap="#classCThreadBaseQueue_ac840c7e7b38eb6407d7d97f5984dba36_icgraph" alt=""/></div>
<map name="classCThreadBaseQueue_ac840c7e7b38eb6407d7d97f5984dba36_icgraph" id="classCThreadBaseQueue_ac840c7e7b38eb6407d7d97f5984dba36_icgraph">
<area shape="rect" id="node2" href="classCThreadBaseQueue.html#aaff1fad9a57494cf93bf57a58231b37d" title="Add command(s) to the queue. " alt="" coords="269,31,488,57"/><area shape="rect" id="node3" href="classCThreadBaseQueue.html#a0fb4074f8b504fcc9fc3e0ba589959f0" title="Add a command to the queue. " alt="" coords="551,5,734,32"/><area shape="rect" id="node4" href="classCThreadResponseQueue.html#a9923da048fd879b5dae6c736df39c0c5" title="Add a command to the queue. " alt="" coords="537,56,749,83"/></map>
</div>
</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a2b42a278890a4e4c06da83cf2d7efb8f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::condition_variable CThreadBaseQueue::_cond</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Condition variable used to signal the arrival of new data in _queue. </p>
<p>In cases of extreme pressure, this is also used to signal the removal of data from a full queue. </p>

<p>Definition at line <a class="el" href="thread__base__queue_8hpp_source.html#l00222">222</a> of file <a class="el" href="thread__base__queue_8hpp_source.html">thread_base_queue.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5ee33dadd7dc4d2848ff58ab90e57cde"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t CThreadBaseQueue::_max_capacity</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The maximum size that _queue can ever grow to before we block and wait for the worker thread to flush it out. </p>
<p>(0 indicates "no limit") </p>

<p>Definition at line <a class="el" href="thread__base__queue_8hpp_source.html#l00229">229</a> of file <a class="el" href="thread__base__queue_8hpp_source.html">thread_base_queue.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="thread__base__queue_8hpp_source.html">thread_base_queue.hpp</a></li>
<li><a class="el" href="thread__base__queue_8cpp_source.html">thread_base_queue.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classCThreadBaseQueue.html">CThreadBaseQueue</a></li>
    <li class="footer">Generated on Fri May 7 2021 20:24:00 for cds_ng by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.5 </li>
  </ul>
</div>
</body>
</html>
